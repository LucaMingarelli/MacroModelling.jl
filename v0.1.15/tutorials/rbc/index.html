<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>RBC · MacroModelling.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MacroModelling.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li class="is-active"><a class="tocitem" href>RBC</a><ul class="internal"><li><a class="tocitem" href="#Define-the-model"><span>Define the model</span></a></li><li><a class="tocitem" href="#Define-the-parameters"><span>Define the parameters</span></a></li><li><a class="tocitem" href="#Plot-impulse-response-functions-(IRFs)"><span>Plot impulse response functions (IRFs)</span></a></li><li><a class="tocitem" href="#Explore-other-parameter-values"><span>Explore other parameter values</span></a></li><li><a class="tocitem" href="#Plot-model-simulation"><span>Plot model simulation</span></a></li><li><a class="tocitem" href="#Plot-specific-series-of-shocks"><span>Plot specific series of shocks</span></a></li><li><a class="tocitem" href="#Model-statistics"><span>Model statistics</span></a></li><li><a class="tocitem" href="#Model-solution"><span>Model solution</span></a></li><li><a class="tocitem" href="#Obtain-array-of-IRFs-or-model-simulations"><span>Obtain array of IRFs or model simulations</span></a></li><li><a class="tocitem" href="#Conditional-forecasts"><span>Conditional forecasts</span></a></li></ul></li><li><a class="tocitem" href="../sw03/">Smets and Wouters (2003)</a></li><li><a class="tocitem" href="../estimation/">Estimation</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../call_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>RBC</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>RBC</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/thorek1/MacroModelling.jl/blob/main/docs/src/tutorials/rbc.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Write-your-first-model-simple-RBC"><a class="docs-heading-anchor" href="#Write-your-first-model-simple-RBC">Write your first model - simple RBC</a><a id="Write-your-first-model-simple-RBC-1"></a><a class="docs-heading-anchor-permalink" href="#Write-your-first-model-simple-RBC" title="Permalink"></a></h1><p>The following tutorial will walk you through the steps of writing down a model (not explained here / taken as given) and analysing it. Prior knowledge of DSGE models and their solution in practical terms (e.g. having used a mod file with dynare) is useful in understanding this tutorial.</p><h2 id="Define-the-model"><a class="docs-heading-anchor" href="#Define-the-model">Define the model</a><a id="Define-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-model" title="Permalink"></a></h2><p>The first step is always to name the model and write down the equations. Taking a standard real business cycle (RBC) model this would go as follows.</p><p>First, we load the package and then use the <a href="../../api/#MacroModelling.@model-Tuple{Any, Any}"><code>@model</code></a> macro to define our model. The first argument after <a href="../../api/#MacroModelling.@model-Tuple{Any, Any}"><code>@model</code></a> is the model name and will be the name of the object in the global environment containing all information regarding the model. The second argument to the macro are the equations, which we write down between <code>begin</code> and <code>end</code>. One equation per line and timing of endogenous variables are expressed in the squared brackets following the variable name. Exogenous variables (shocks) are followed by a keyword in squared brackets indicating them being exogenous (in this case <code>[x]</code>). Note that names can leverage julias unicode capabilities (<code>alpha</code> can be written as <code>α</code>).</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using MacroModelling</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @model RBC begin
           1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
           c[0] + k[0] = (1 - δ) * k[-1] + q[0]
           q[0] = exp(z[0]) * k[-1]^α
           z[0] = ρ * z[-1] + std_z * eps_z[x]
       end</code><code class="nohighlight hljs ansi" style="display:block;">Model:      RBC
Variables
 Total:     4
 States:    2
 Jumpers:   1
 Auxiliary: 0
Shocks:     1
Parameters: 5</code></pre><p>After the model is parsed we get some info on the model variables, and parameters.</p><h2 id="Define-the-parameters"><a class="docs-heading-anchor" href="#Define-the-parameters">Define the parameters</a><a id="Define-the-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-parameters" title="Permalink"></a></h2><p>Next we need to add the parameters of the model. The macro <a href="../../api/#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}"><code>@parameters</code></a> takes care of this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @parameters RBC begin
           std_z = 0.01
           ρ = 0.2
           δ = 0.02
           α = 0.5
           β = 0.95
       end</code><code class="nohighlight hljs ansi" style="display:block;">Remove redundant variables in non stochastic steady state problem:	2.386 seconds
Set up non stochastic steady state problem:	6.776 seconds
Take symbolic derivatives up to first order:	6.401 seconds
Find non stochastic steady state:	0.326 seconds
Model:      RBC
Variables
 Total:     4
 States:    2
 Jumpers:   1
 Auxiliary: 0
Shocks:     1
Parameters: 5</code></pre><p>Parameter definitions are similar to assigning values in julia. Note that we have to write one parameter definition per line.</p><h2 id="Plot-impulse-response-functions-(IRFs)"><a class="docs-heading-anchor" href="#Plot-impulse-response-functions-(IRFs)">Plot impulse response functions (IRFs)</a><a id="Plot-impulse-response-functions-(IRFs)-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-impulse-response-functions-(IRFs)" title="Permalink"></a></h2><p>Given the equations and parameters, we have everything to solve the model and do some analysis. A common output are IRFs for the exogenous shocks. Calling <a href="tutorials/@ref"><code>plot_irf</code></a> (different names for the same function are also supported: <a href="tutorials/@ref"><code>plot_irfs</code></a>, or <a href="tutorials/@ref"><code>plot_IRF</code></a>) will take care of this. Please note that you need to import the <code>Plots</code> and <code>StatsPlots</code> packages once before the first plot. In the background the package solves (symbolically in this simple case) for the non stochastic steady state (SS) and calculates the first order perturbation solution.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import Plots, StatsPlots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_irf(RBC)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Any}:
 Plot{Plots.GRBackend() n=14}</code></pre><p><img src="../../assets/irf__RBC__eps_z__1.png" alt="RBC IRF"/></p><p>When the model is solved the first time (in this case by calling <a href="tutorials/@ref"><code>plot_irf</code></a>), the package breaks down the steady state problem into independent blocks and first attempts to solve them symbolically and if that fails numerically.</p><p>The plot shows the responses of the endogenous variables (<code>c</code>, <code>k</code>, <code>q</code>, and <code>z</code>) to a one standard deviation positive (indicated by Shock⁺ in chart title) unanticipated shock in  <code>eps_z</code>. Therefore there are as many subplots as there are combinations of shocks and endogenous variables (which are impacted by the shock). Plots are composed of up to 9 subplots and the plot title shows the model name followed by the name of the shock and which plot we are seeing out of the plots for this shock (e.g. (1/3) means we see the first out of three plots for this shock). Subplots show the sorted endogenous variables with the left y-axis showing the level of the respective variable and the right y-axis showing the percent deviation from the SS (if variable is strictly positive). The horizontal black line marks the SS.</p><h2 id="Explore-other-parameter-values"><a class="docs-heading-anchor" href="#Explore-other-parameter-values">Explore other parameter values</a><a id="Explore-other-parameter-values-1"></a><a class="docs-heading-anchor-permalink" href="#Explore-other-parameter-values" title="Permalink"></a></h2><p>Playing around with the model can be especially insightful in the early phase of model development. The package tries to facilitates this process to the extent possible. Typically one wants to try different parameter values and see how the IRFs change. This can be done by using the <code>parameters</code> argument of the <a href="tutorials/@ref"><code>plot_irf</code></a> function. We pass a <code>Pair</code> with the <code>Symbol</code> of the parameter (<code>:</code> in front of the parameter name) we want to change and its new value to the <code>parameter</code> argument (e.g. <code>:α =&gt; 0.3</code>).</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_irf(RBC, parameters = :α =&gt; 0.3)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Any}:
 Plot{Plots.GRBackend() n=14}</code></pre><p><img src="../../assets/irf__RBC_new__eps_z__1.png" alt="IRF plot"/></p><p>First, the package finds the new steady state, solves the model dynamics around it and saves the new parameters and solution in the model object. Second, note that the shape of the curves in the plot and the y-axis values changed. Updating the plot for new parameters is significantly faster than calling it the first time. This is because the first call triggers compilations of the model functions, and once compiled the user benefits from the performance of the specialised compiled code.</p><h2 id="Plot-model-simulation"><a class="docs-heading-anchor" href="#Plot-model-simulation">Plot model simulation</a><a id="Plot-model-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-model-simulation" title="Permalink"></a></h2><p>Another insightful output is simulations of the model. Here we can use the <a href="tutorials/@ref"><code>plot_simulations</code></a> function. Please note that you need to import the <code>Plots</code> and <code>StatsPlots</code> packages once before the first plot. To the same effect we can use the <a href="tutorials/@ref"><code>plot_irf</code></a> function and specify in the <code>shocks</code> argument that we want to <code>:simulate</code> the model and set the <code>periods</code> argument to 100.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_simulations(RBC)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Any}:
 Plot{Plots.GRBackend() n=14}</code></pre><p><img src="../../assets/irf__RBC_sim__eps_z__1.png" alt="Simulate RBC"/></p><p>The plots show the models endogenous variables in response to random draws for all exogenous shocks over 100 periods.</p><h2 id="Plot-specific-series-of-shocks"><a class="docs-heading-anchor" href="#Plot-specific-series-of-shocks">Plot specific series of shocks</a><a id="Plot-specific-series-of-shocks-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-specific-series-of-shocks" title="Permalink"></a></h2><p>Sometimes one has a specific series of shocks in mind and wants to see the corresponding model response of endogenous variables. This can be achieved by passing a <code>Matrix</code> or <code>KeyedArray</code> of the series of shocks to the <code>shocks</code> argument of the <a href="tutorials/@ref"><code>plot_irf</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; shock_series = zeros(1,4)</code><code class="nohighlight hljs ansi" style="display:block;">1×4 Matrix{Float64}:
 0.0  0.0  0.0  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; shock_series[1,2] = 1</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; shock_series[1,4] = -1</code><code class="nohighlight hljs ansi" style="display:block;">-1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_irf(RBC, shocks = shock_series)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Any}:
 Plot{Plots.GRBackend() n=14}</code></pre><p><img src="../../assets/irf__RBC__shock_matrix__1.png" alt="Series of shocks RBC"/></p><p>The plot shows the two shocks hitting the economy in periods 2 and 4 and then continues the simulation for 40 more quarters.</p><h2 id="Model-statistics"><a class="docs-heading-anchor" href="#Model-statistics">Model statistics</a><a id="Model-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Model-statistics" title="Permalink"></a></h2><p>The package solves for the SS automatically and we got an idea of the SS values in the plots. If we want to see the SS values we can call <a href="../../api/#MacroModelling.get_steady_state-Tuple{MacroModelling.ℳ}"><code>get_steady_state</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_steady_state(RBC)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables_and_calibrated_parameters ∈ 4-element Vector{Symbol}
→   Steady_state_and_∂steady_state∂parameter ∈ 6-element Vector{Symbol}
And data, 4×6 Matrix{Float64}:
        (:Steady_state)  (:std_z)  (:ρ)    (:δ)     (:α)       (:β)
  (:c)   1.68482          0.0       0.0   -15.4383   6.77814    8.70101
  (:k)   7.58567          0.0       0.0  -149.201   58.0802   165.319
  (:q)   1.83653          0.0       0.0   -10.8367   7.93974   12.0074
  (:z)   0.0              0.0       0.0     0.0      0.0        0.0</code></pre><p>to get the SS and the derivatives of the SS with respect to the model parameters. The first column of the returned matrix shows the SS while the second to last columns show the derivatives of the SS values (indicated in the rows) with respect to the parameters (indicated in the columns). For example, the derivative of <code>k</code> with respect to <code>β</code> is 165.319. This means that if we increase <code>β</code> by 1, <code>k</code> would increase by 165.319 approximately. Let&#39;s see how this plays out by changing <code>β</code> from 0.95 to 0.951 (a change of +0.001):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_steady_state(RBC,parameters = :β =&gt; .951)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables_and_calibrated_parameters ∈ 4-element Vector{Symbol}
→   Steady_state_and_∂steady_state∂parameter ∈ 6-element Vector{Symbol}
And data, 4×6 Matrix{Float64}:
        (:Steady_state)  (:std_z)  (:ρ)    (:δ)     (:α)       (:β)
  (:c)   1.69358          0.0       0.0   -15.7336   6.85788    8.82312
  (:k)   7.75393          0.0       0.0  -154.87    59.6114   171.24
  (:q)   1.84866          0.0       0.0   -11.077    8.05011   12.2479
  (:z)   0.0              0.0       0.0     0.0      0.0        0.0</code></pre><p>Note that <a href="../../api/#MacroModelling.get_steady_state-Tuple{MacroModelling.ℳ}"><code>get_steady_state</code></a> like all other get functions has the <code>parameters</code> argument. Hence, whatever output we are looking at we can change the parameters of the model.</p><p>The new value of <code>β</code> changed the SS as expected and <code>k</code> increased by 0.168. The elasticity (0.168/0.001) comes close to the partial derivative previously calculated. The derivatives help understanding the effect of parameter changes on the steady state and make for easier navigation of the parameter space.</p><h3 id="Standard-deviations"><a class="docs-heading-anchor" href="#Standard-deviations">Standard deviations</a><a id="Standard-deviations-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-deviations" title="Permalink"></a></h3><p>Next to the SS we can also show the model implied standard deviations of the model. <a href="../../api/#MacroModelling.get_standard_deviation-Tuple"><code>get_standard_deviation</code></a> takes care of this. Additionally we will set the parameter values to what they were in the beginning by passing on a <code>Tuple</code> of <code>Pair</code>s containing the <code>Symbol</code>s of the parameters to be changed and their new (initial) values (e.g. <code>(:α =&gt; 0.5, :β =&gt; .95)</code>).</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_standard_deviation(RBC, parameters = (:α =&gt; 0.5, :β =&gt; .95))</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 4-element Vector{Symbol}
→   Standard_deviation_and_∂standard_deviation∂parameter ∈ 6-element Vector{Symbol}
And data, 4×6 Matrix{Float64}:
        (:Standard_deviation)  (:std_z)  …  (:δ)       (:α)       (:β)
  (:c)   0.0266642              2.66642     -0.384359   0.2626     0.144789
  (:k)   0.264677              26.4677      -5.74194    2.99332    6.30323
  (:q)   0.0739325              7.39325     -0.974722   0.726551   1.08
  (:z)   0.0102062              1.02062      0.0        0.0        0.0</code></pre><p>The function returns the model implied standard deviations of the model variables and their derivatives with respect to the model parameters. For example, the derivative of the standard deviation of <code>c</code> with resect to <code>δ</code> is -0.384. In other words, the standard deviation of <code>c</code> decreases with increasing <code>δ</code>.</p><h3 id="Correlations"><a class="docs-heading-anchor" href="#Correlations">Correlations</a><a id="Correlations-1"></a><a class="docs-heading-anchor-permalink" href="#Correlations" title="Permalink"></a></h3><p>Another useful statistic is the model implied correlation of variables. We use <a href="../../api/#MacroModelling.get_correlation-Tuple{MacroModelling.ℳ}"><code>get_correlation</code></a> for this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_correlation(RBC)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 4-element Vector{Symbol}
→   𝑉𝑎𝑟𝑖𝑎𝑏𝑙𝑒𝑠 ∈ 4-element Vector{Symbol}
And data, 4×4 Matrix{Float64}:
        (:c)       (:k)       (:q)       (:z)
  (:c)   1.0        0.999812   0.550168   0.314562
  (:k)   0.999812   1.0        0.533879   0.296104
  (:q)   0.550168   0.533879   1.0        0.965726
  (:z)   0.314562   0.296104   0.965726   1.0</code></pre><h3 id="Autocorrelations"><a class="docs-heading-anchor" href="#Autocorrelations">Autocorrelations</a><a id="Autocorrelations-1"></a><a class="docs-heading-anchor-permalink" href="#Autocorrelations" title="Permalink"></a></h3><p>Last but not least, we have a look at the model implied autocorrelations of model variables using the <a href="../../api/#MacroModelling.get_autocorrelation-Tuple{MacroModelling.ℳ}"><code>get_autocorrelation</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_autocorrelation(RBC)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 4-element Vector{Symbol}
→   Autocorrelation_orders ∈ 5-element UnitRange{Int64}
And data, 4×5 Matrix{Float64}:
        (1)         (2)         (3)         (4)         (5)
  (:c)    0.966974    0.927263    0.887643    0.849409    0.812761
  (:k)    0.971015    0.931937    0.892277    0.853876    0.817041
  (:q)    0.32237     0.181562    0.148347    0.136867    0.129944
  (:z)    0.2         0.04        0.008       0.0016      0.00032</code></pre><h2 id="Model-solution"><a class="docs-heading-anchor" href="#Model-solution">Model solution</a><a id="Model-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Model-solution" title="Permalink"></a></h2><p>A further insightful output are the policy and transition functions of the the first order perturbation solution. To retrieve the solution we call the function <a href="../../api/#MacroModelling.get_solution-Tuple{MacroModelling.ℳ}"><code>get_solution</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_solution(RBC)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Steady_state__States__Shocks ∈ 4-element Vector{Symbol}
→   Variables ∈ 4-element Vector{Symbol}
And data, 4×4 adjoint(::Matrix{Float64}) with eltype Float64:
                   (:c)         (:k)        (:q)        (:z)
  (:Steady_state)   5.93625     47.3903      6.88406     0.0
  (:k₍₋₁₎)          0.0957964    0.956835    0.0726316   0.0
  (:z₍₋₁₎)          0.134937     1.24187     1.37681     0.2
  (:eps_z₍ₓ₎)       0.00674687   0.0620937   0.0688406   0.01</code></pre><p>The solution provides information about how past states and present shocks impact present variables. The first row contains the SS for the variables denoted in the columns. The second to last rows contain the past states, with the time index <code>₍₋₁₎</code>, and present shocks, with exogenous variables denoted by <code>₍ₓ₎</code>. For example, the immediate impact of a shock to <code>eps_z</code> on <code>q</code> is 0.0688.</p><p>There is also the possibility to visually inspect the solution. Please note that you need to import the <code>Plots</code> and <code>StatsPlots</code> packages once before the first plot. We can use the <a href="tutorials/@ref"><code>plot_solution</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_solution(RBC, :k)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Any}:
 Plot{Plots.GRBackend() n=11}</code></pre><p><img src="../../assets/solution__RBC__1.png" alt="RBC solution"/></p><p>The chart shows the first order perturbation solution mapping from the past state <code>k</code> to the present variables of the model. The state variable covers a range of two standard deviations around the non stochastic steady state and all other states remain in the non stochastic steady state.</p><h2 id="Obtain-array-of-IRFs-or-model-simulations"><a class="docs-heading-anchor" href="#Obtain-array-of-IRFs-or-model-simulations">Obtain array of IRFs or model simulations</a><a id="Obtain-array-of-IRFs-or-model-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Obtain-array-of-IRFs-or-model-simulations" title="Permalink"></a></h2><p>Last but not least the user might want to obtain simulated time series of the model or IRFs without plotting them. For IRFs this is possible by calling <a href="../../api/#MacroModelling.get_irf-Tuple{MacroModelling.ℳ, Vector}"><code>get_irf</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_irf(RBC)</code><code class="nohighlight hljs ansi" style="display:block;">3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 4-element Vector{Symbol}
→   Periods ∈ 40-element UnitRange{Int64}
◪   Shocks ∈ 1-element Vector{Symbol}
And data, 4×40×1 Array{Float64, 3}:
[:, :, 1] ~ (:, :, :eps_z):
        (1)           (2)           …  (39)            (40)
  (:c)    0.00674687    0.00729773        0.00146962      0.00140619
  (:k)    0.0620937     0.0718322         0.0146789       0.0140453
  (:q)    0.0688406     0.0182781         0.00111425      0.00106615
  (:z)    0.01          0.002             2.74878e-29     5.49756e-30</code></pre><p>which returns a 3-dimensional <code>KeyedArray</code> with variables in rows, the period in columns, and the shocks as the third dimension.</p><p>For simulations this is possible by calling <a href="../../api/#MacroModelling.simulate-Tuple"><code>simulate</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; simulate(RBC)</code><code class="nohighlight hljs ansi" style="display:block;">3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 4-element Vector{Symbol}
→   Periods ∈ 40-element UnitRange{Int64}
◪   Shocks ∈ 1-element Vector{Symbol}
And data, 4×40×1 Array{Float64, 3}:
[:, :, 1] ~ (:, :, :simulate):
        (1)           (2)           …  (39)           (40)
  (:c)   -0.00687213   -0.00795358       -0.0403579     -0.0433661
  (:k)   -0.0632465    -0.0779549        -0.39888       -0.429104
  (:q)   -0.0701187    -0.0239268        -0.0814217     -0.0815677
  (:z)   -0.0101857    -0.00280839       -0.00797531    -0.00764032</code></pre><p>which returns the simulated data in a 3-dimensional <code>KeyedArray</code> of the same structure as for the IRFs.</p><h2 id="Conditional-forecasts"><a class="docs-heading-anchor" href="#Conditional-forecasts">Conditional forecasts</a><a id="Conditional-forecasts-1"></a><a class="docs-heading-anchor-permalink" href="#Conditional-forecasts" title="Permalink"></a></h2><p>Conditional forecasting is a useful tool to incorporate for example forecasts into a model and then add shocks on top.</p><p>For example we might be interested in the model dynamics given a path for <code>c</code> for the first 4 quarters and the next quarter a negative shock to <code>eps_z</code> arrives. This can be implemented using the <code>get_conditional_forecast</code> function and visualised with the <code>plot_conditional_forecast</code> function.</p><p>First, we define the conditions on the endogenous variables as deviations from the non stochastic steady state (<code>c</code> in this case) using a <code>KeyedArray</code> from the <code>AxisKeys</code> package (check <a href="../../api/#MacroModelling.get_conditional_forecast-Tuple{MacroModelling.ℳ, Union{AxisKeys.KeyedArray{Union{Nothing, Float64}}, AxisKeys.KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}"><code>get_conditional_forecast</code></a> for other ways to define the conditions):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using AxisKeys</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conditions = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,4),Variables = [:c], Periods = 1:4)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables ∈ 1-element Vector{Symbol}
→   Periods ∈ 4-element UnitRange{Int64}
And data, 1×4 Matrix{Union{Nothing, Float64}}:
        (1)         (2)         (3)         (4)
  (:c)     nothing     nothing     nothing     nothing</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conditions[1:4] .= [-.01,0,.01,.02];</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Note that all other endogenous variables not part of the <code>KeyedArray</code> are also not conditioned on.</p><p>Next, we define the conditions on the shocks (<code>eps_z</code> in this case) using a <code>SparseArrayCSC</code> from the <code>SparseArrays</code> package (check <a href="../../api/#MacroModelling.get_conditional_forecast-Tuple{MacroModelling.ℳ, Union{AxisKeys.KeyedArray{Union{Nothing, Float64}}, AxisKeys.KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}"><code>get_conditional_forecast</code></a> for other ways to define the conditions on the shocks):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SparseArrays</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; shocks = spzeros(1,5)</code><code class="nohighlight hljs ansi" style="display:block;">1×5 SparseArrays.SparseMatrixCSC{Float64, Int64} with 0 stored entries:
  ⋅    ⋅    ⋅    ⋅    ⋅</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; shocks[1,5] = -1;</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Note that for the first 4 periods the shock has no predetermined value and is determined by the conditions on the endogenous variables.</p><p>Finally we can get the conditional forecast:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get_conditional_forecast(RBC, conditions, shocks = shocks)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
↓   Variables_and_shocks ∈ 5-element Vector{Symbol}
→   Periods ∈ 45-element UnitRange{Int64}
And data, 5×45 Matrix{Float64}:
               (1)          (2)           …  (44)           (45)
  (:c)          -0.01         0.0               0.0023348      0.00223402
  (:k)          -0.0920334   -0.00691984        0.0233205      0.0223139
  (:q)          -0.102033     0.0832729         0.00177022     0.0016938
  (:z)          -0.0148217    0.0130675        -3.6669e-30    -7.3338e-31
  (:eps_z₍ₓ₎)   -1.48217      1.60318     …     0.0            0.0</code></pre><p>The function returns a <code>KeyedArray</code> with the values of the endogenous variables and shocks matching the conditions exactly.</p><p>We can also plot the conditional forecast. Please note that you need to import the <code>Plots</code> and <code>StatsPlots</code> packages once before the first plot. In order to plot we can use:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot_conditional_forecast(RBC, conditions, shocks = shocks)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Any}:
 Plot{Plots.GRBackend() n=20}</code></pre><p><img src="../../assets/conditional_fcst__RBC__conditional_forecast__1.png" alt="RBC conditional forecast"/></p><p>Note that the stars indicate the values the model is conditioned on.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../install/">« Installation</a><a class="docs-footer-nextpage" href="../sw03/">Smets and Wouters (2003) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 21 April 2023 17:54">Friday 21 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
