<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API ¬∑ MacroModelling.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroModelling.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/install/">Installation</a></li><li><a class="tocitem" href="../tutorials/rbc/">RBC</a></li><li><a class="tocitem" href="../tutorials/sw03/">Smets and Wouters (2003)</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a></li><li><a class="tocitem" href="../call_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/thorek1/MacroModelling.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.get_IRF" href="#MacroModelling.get_IRF"><code>MacroModelling.get_IRF</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}"><code>get_irf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/get_functions.jl#L229-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.get_SS" href="#MacroModelling.get_SS"><code>MacroModelling.get_SS</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/get_functions.jl#L362-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.get_first_order_solution" href="#MacroModelling.get_first_order_solution"><code>MacroModelling.get_first_order_solution</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}"><code>get_solution</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/get_functions.jl#L423-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}" href="#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}"><code>MacroModelling.get_irf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_irf(
    ùìÇ,
    parameters;
    periods,
    variables,
    shocks,
    negative_shock,
    initial_state,
    levels
)
</code></pre><p>Return impulse response functions (IRFs) of the model in a 3-dimensional array. Function to use when differentiating IRFs with repect to parameters.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by @model and @parameters for which to get the solution.</li><li><code>parameters</code> [Type: <code>Vector</code>]: Parameter values in alphabetical order (sorted by parameter name).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: number of periods for which to calculate the IRFs</li><li><code>variables</code> [Default: <code>:all</code>]: variables for which to calculate the IRFs. Inputs can be either a <code>Symbol</code> (e.g. <code>:y</code> or <code>:all</code>), <code>Tuple{Symbol, Vararg{Symbol}}</code>, <code>Matrix{Symbol}</code> or <code>Vector{Symbol}</code>. Any variables not part of the model will trigger a warning.</li><li><code>shocks</code> [Default: <code>:all</code>]: shocks for which to calculate the IRFs. Inputs can be either a <code>Symbol</code> (e.g. <code>:y</code>, <code>:simulate</code>, :none, or <code>:all</code>), <code>Tuple{Symbol, Vararg{Symbol}}</code>, <code>Matrix{Symbol}</code> or <code>Vector{Symbol}</code>. <code>:simulate</code> triggers random draws of all shocks. Any shocks not part of the model will trigger a warning. <code>:none</code> in combination with an <code>initial_state</code> can be used for deterministic simulations.</li><li><code>negative_shock</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate a negative shock. Relevant for generalised IRFs.</li><li><code>generalised_irf</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate generalised IRFs. Relevant for nonlinear solutions. Reference steady state for deviations is the stochastic steady state.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Vector{Float64}</code>]: provide state from which to start IRFs. Relevant for normal IRFs.</li><li><code>levels</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return levels or absolute deviations from steady state</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end;

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end;

get_irf(RBC, RBC.parameter_values)
# output
4√ó40√ó1 Array{Float64, 3}:
[:, :, 1] =
 0.00674687  0.00729773  0.00715114  0.00687615  ‚Ä¶  0.00146962   0.00140619
 0.0620937   0.0718322   0.0712153   0.0686381      0.0146789    0.0140453
 0.0688406   0.0182781   0.00797091  0.0057232      0.00111425   0.00106615
 0.01        0.002       0.0004      8.0e-5         2.74878e-29  5.49756e-30</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/get_functions.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_irf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_irf(
    ùìÇ;
    periods,
    algorithm,
    parameters,
    variables,
    shocks,
    negative_shock,
    generalised_irf,
    initial_state,
    levels
)
</code></pre><p>Return impulse response functions (IRFs) of the model in a 3-dimensional KeyedArray</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by @model and @parameters for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: number of periods for which to calculate the IRFs</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: <code>Symbol</code>]: solution algorithm for which to show the IRFs</li><li><code>parameters</code> : If nothing is provided, the solution is calculated for the parameters defined previously. If a vector with parameter values, or a named tuple is provided and the parameters differ from the previously defined the solution will be recalculated. </li><li><code>variables</code> [Default: <code>:all</code>]: variables for which to calculate the IRFs. Inputs can be either a <code>Symbol</code> (e.g. <code>:y</code> or <code>:all</code>), <code>Tuple{Symbol, Vararg{Symbol}}</code>, <code>Matrix{Symbol}</code> or <code>Vector{Symbol}</code>. Any variables not part of the model will trigger a warning.</li><li><code>shocks</code> [Default: <code>:all</code>]: shocks for which to calculate the IRFs. Inputs can be either a <code>Symbol</code> (e.g. <code>:y</code>, <code>:simulate</code>, :none, or <code>:all</code>), <code>Tuple{Symbol, Vararg{Symbol}}</code>, <code>Matrix{Symbol}</code> or <code>Vector{Symbol}</code>. <code>:simulate</code> triggers random draws of all shocks. Any shocks not part of the model will trigger a warning. <code>:none</code> in combination with an <code>initial_state</code> can be used for deterministic simulations.</li><li><code>negative_shock</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate a negative shock. Relevant for generalised IRFs.</li><li><code>generalised_irf</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate generalised IRFs. Relevant for nonlinear solutions. Reference steady state for deviations is the stochastic steady state.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Vector{Float64}</code>]: provide state from which to start IRFs. Relevant for normal IRFs.</li><li><code>levels</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return levels or absolute deviations from steady state</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end;

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end;

get_irf(RBC)
# output
3-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Period ‚àà 40-element UnitRange{Int64}
‚ó™   Shock ‚àà 1-element Vector{Symbol}
And data, 4√ó40√ó1 Array{Float64, 3}:
[:, :, 1] ~ (:, :, :eps_z):
        (1)           (2)           ‚Ä¶  (39)            (40)
  (:c)    0.00674687    0.00729773        0.00146962      0.00140619
  (:k)    0.0620937     0.0718322         0.0146789       0.0140453
  (:q)    0.0688406     0.0182781         0.00111425      0.00106615
  (:z)    0.01          0.002             2.74878e-29     5.49756e-30</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/get_functions.jl#L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.get_irfs" href="#MacroModelling.get_irfs"><code>MacroModelling.get_irfs</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}"><code>get_irf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/get_functions.jl#L224-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥, Vector}" href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥, Vector}"><code>MacroModelling.get_moments</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_moments(
    ùìÇ,
    parameters;
    non_stochastic_steady_state,
    standard_deviation,
    variance,
    covariance
)
</code></pre><p>Return the first and second moments of endogenous variables using the linearised solution. By default returns: non stochastic steady state (SS), and standard deviations, but can also return variances, and covariance matrix. Function to use when differentiating model moments with repect to parameters.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by @model and @parameters for which to get the solution.</li><li><code>parameters</code> [Type: <code>Vector</code>]: Parameter values in alphabetical order (sorted by parameter name).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>non_stochastic_steady_state</code> [Default: <code>true</code>, Type: <code>Bool</code>]: switch to return SS of endogenous variables</li><li><code>standard_deviation</code> [Default: <code>true</code>, Type: <code>Bool</code>]: switch to return standard deviation of endogenous variables</li><li><code>variance</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to return variance of endogenous variables</li><li><code>covariance</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to return covariance matrix of endogenous variables</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end;

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end;

get_moments(RBC, RBC.parameter_values)
# output
2-element Vector{Any}:
 [5.936252888048724, 47.39025414828808, 6.884057971014486, 0.0]
 [0.02666420378525522, 0.26467737291222343, 0.07393254045396495, 0.010206207261596576]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/get_functions.jl#L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_moments</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_moments(
    ùìÇ;
    parameters,
    non_stochastic_steady_state,
    standard_deviation,
    variance,
    covariance,
    derivatives,
    parameter_derivatives
)
</code></pre><p>Return the first and second moments of endogenous variables using the linearised solution. By default returns: non stochastic steady state (SS), and standard deviations, but can also return variances, and covariance matrix. Function to use when differentiating model moments with repect to parameters.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by @model and @parameters for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> : If nothing is provided, the solution is calculated for the parameters defined previously. If a vector with parameter values, or a named tuple is provided and the parameters differ from the previously defined the solution will be recalculated. </li><li><code>non_stochastic_steady_state</code> [Default: <code>true</code>, Type: <code>Bool</code>]: switch to return SS of endogenous variables</li><li><code>standard_deviation</code> [Default: <code>true</code>, Type: <code>Bool</code>]: switch to return standard deviation of endogenous variables</li><li><code>variance</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to return variance of endogenous variables</li><li><code>covariance</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to return covariance matrix of endogenous variables</li><li><code>derivatives</code> [Default: true, Type: <code>Bool</code>]: switch to calculate derivatives of SS, standard deviation, and variance with respect to the parameters</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end;

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end;

moments = get_moments(RBC);

moments[1]
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Steady_state_and_‚àÇsteady_state‚àÇparameter ‚àà 6-element Vector{Symbol}
And data, 4√ó6 Matrix{Float64}:
        (:Steady_state)  (:std_z)  (:œÅ)     (:Œ¥)      (:Œ±)       (:Œ≤)
  (:c)   5.93625          0.0       0.0   -116.072    55.786     76.1014
  (:k)  47.3903           0.0       0.0  -1304.95    555.264   1445.93
  (:q)   6.88406          0.0       0.0    -94.7805   66.8912   105.02
  (:z)   0.0              0.0       0.0      0.0       0.0        0.0</code></pre><pre><code class="language-julia hljs">moments[2]
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables ‚àà 4-element Vector{Symbol}
‚Üí   Standard_deviation_and_‚àÇstandard_deviation‚àÇparameter ‚àà 6-element Vector{Symbol}
And data, 4√ó6 Matrix{Float64}:
        (:Standard_deviation)  (:std_z)  ‚Ä¶  (:Œ¥)       (:Œ±)       (:Œ≤)
  (:c)   0.0266642              2.66642     -0.384359   0.2626     0.144789
  (:k)   0.264677              26.4677      -5.74194    2.99332    6.30323
  (:q)   0.0739325              7.39325     -0.974722   0.726551   1.08
  (:z)   0.0102062              1.02062      0.0        0.0        0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/get_functions.jl#L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.get_non_stochastic_steady_state-Tuple" href="#MacroModelling.get_non_stochastic_steady_state-Tuple"><code>MacroModelling.get_non_stochastic_steady_state</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a> with <code>stochastic = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/get_functions.jl#L350-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.get_perturbation_solution" href="#MacroModelling.get_perturbation_solution"><code>MacroModelling.get_perturbation_solution</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}"><code>get_solution</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/get_functions.jl#L428-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_solution</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_solution(ùìÇ; parameters)
</code></pre><p>Return the linearised solution and the non stochastic steady state (SS) of the model.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by <a href="#MacroModelling.@model-Tuple{Any, Any}"><code>@model</code></a> and <a href="#MacroModelling.@parameters-Tuple{Any, Any}"><code>@parameters</code></a> for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> : If nothing is provided, the solution is calculated for the parameters defined previously. If a vector with parameter values, or a named tuple is provided and the parameters differ from the previously defined the solution will be recalculated. </li></ul><p>The returned <code>KeyedArray</code> shows the SS, policy and transition functions of the model. The columns show the varibales including auxilliary endogenous and exogenous variables (due to leads and lags &gt; 1). The rows are the SS, followed by the states, and exogenous shocks.  Subscripts following variable names indicate the timing (e.g. <code>variable‚Çç‚Çã‚ÇÅ‚Çé</code>  indicates the variable being in the past). Superscripts indicate leads or lags (e.g. <code>variable·¥∏‚ÅΩ¬≤‚Åæ</code> indicates the variable being in lead by two periods). If no super- or subscripts follow the variable name, the variable is in the present.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end;

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end;

get_solution(RBC)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Steady_state__States__Shocks ‚àà 4-element Vector{Symbol}
‚Üí   Variable ‚àà 4-element Vector{Symbol}
And data, 4√ó4 adjoint(::Matrix{Float64}) with eltype Float64:
                   (:c)         (:k)        (:q)        (:z)
  (:Steady_state)   5.93625     47.3903      6.88406     0.0
  (:k‚Çç‚Çã‚ÇÅ‚Çé)          0.0957964    0.956835    0.0726316  -0.0
  (:z‚Çç‚Çã‚ÇÅ‚Çé)          0.134937     1.24187     1.37681     0.2
  (:eps_z‚Çç‚Çì‚Çé)       0.00674687   0.0620937   0.0688406   0.01</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/get_functions.jl#L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.get_steady_state</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_steady_state(
    ùìÇ;
    parameters,
    derivatives,
    stochastic,
    parameter_derivatives
)
</code></pre><p>Return the (non stochastic) steady state and derivatives with respect to model parameters.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by @model and @parameters for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parameters</code> : If nothing is provided, the solution is calculated for the parameters defined previously. If a vector with parameter values, or a named tuple is provided and the parameters differ from the previously defined the solution will be recalculated. </li><li><code>derivatives</code> [Default: <code>true</code>, Type: <code>Bool</code>]: calculate derivatives of the SS with respect to the parameters</li><li><code>stochastic</code> [Default: <code>false</code>, Type: <code>Bool</code>]: return stochastic steady state using second order perturbation. No derivatives are calculated.</li></ul><p>The columns show the SS and parameters for which derivatives are taken. The rows show the variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end;

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end;

get_steady_state(RBC)
# output
2-dimensional KeyedArray(NamedDimsArray(...)) with keys:
‚Üì   Variables_and_calibrated_parameters ‚àà 4-element Vector{Symbol}
‚Üí   Steady_state_and_‚àÇsteady_state‚àÇparameter ‚àà 6-element Vector{Symbol}
And data, 4√ó6 Matrix{Float64}:
        (:Steady_state)  (:std_z)  (:œÅ)     (:Œ¥)      (:Œ±)       (:Œ≤)
  (:c)   5.93625          0.0       0.0   -116.072    55.786     76.1014
  (:k)  47.3903           0.0       0.0  -1304.95    555.264   1445.93
  (:q)   6.88406          0.0       0.0    -94.7805   66.8912   105.02
  (:z)   0.0              0.0       0.0      0.0       0.0        0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/get_functions.jl#L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.get_stochastic_steady_state-Tuple" href="#MacroModelling.get_stochastic_steady_state-Tuple"><code>MacroModelling.get_stochastic_steady_state</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}"><code>get_steady_state</code></a> with <code>stochastic = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/get_functions.jl#L356-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.plot-Tuple{MacroModelling.‚Ñ≥}" href="#MacroModelling.plot-Tuple{MacroModelling.‚Ñ≥}"><code>MacroModelling.plot</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(
    ùìÇ;
    periods,
    shocks,
    variables,
    parameters,
    show_plots,
    save_plots,
    save_plots_format,
    save_plots_path,
    plots_per_page,
    algorithm,
    negative_shock,
    generalised_irf,
    initial_state
)
</code></pre><p>Plot impulse response functions (IRFs) of the model.</p><p>The left axis shows the level, and the right the deviation from the reference steady state. Linear solutions have the non stochastic steady state as reference other solutoin the stochastic steady state. The horizontal black line indicates the reference steady state. Variable names are above the subplots and the title provides information about the model, shocks and number of pages per shock.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: the object created by @model and @parameters for which to get the solution.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>plots_per_page</code> [Default: <code>9</code>, Type: <code>Int</code>]: how many plots to show per page</li><li><code>save_plots</code> [Default: <code>false</code>, Type: <code>Bool</code>]: switch to save plots using path and extension from <code>save_plots_path</code> and <code>save_plots_format</code>. Separate files per shocks and variables depending on number of variables and <code>plots_per_page</code></li><li><code>save_plots_path</code> [Default: <code>pwd()</code>, Type: <code>String</code>]: path where to save plots</li><li><code>save_plots_format</code> [Default: <code>:pdf</code>, Type: <code>Symbol</code>]: output format of saved plots. See <a href="https://docs.juliaplots.org/latest/output/#Supported-output-file-formats">input formats compatible with GR</a> for valid formats.</li><li><code>show_plots</code> [Default: <code>true</code>, Type: <code>Bool</code>]: show plots. Separate plots per shocks and varibles depending on number of variables and <code>plots_per_page</code>.</li><li><code>periods</code> [Default: <code>40</code>, Type: <code>Int</code>]: number of periods for which to calculate the IRFs</li><li><code>algorithm</code> [Default: <code>:first_order</code>, Type: Symbol]: solution algorithm for which to show the IRFs</li><li><code>parameters</code> : If nothing is provided, the solution is calculated for the parameters defined previously. If a vector with parameter values, or a named tuple is provided and the parameters differ from the previously defined the solution will be recalculated. </li><li><code>variables</code> [Default: <code>:all</code>]: variables for which to calculate the IRFs. Inputs can be either a <code>Symbol</code> (e.g. <code>:y</code> or <code>:all</code>), <code>Matrix{Symbol}</code> or <code>Vector{Symbol}</code>. Any variables not part of the model will trigger a warning.</li><li><code>shocks</code> [Default: <code>:all</code>]: shocks for which to calculate the IRFs. Inputs can be either a <code>Symbol</code> (e.g. <code>:y</code>, <code>:simulate</code>, :none, or <code>:all</code>), <code>Matrix{Symbol}</code> or <code>Vector{Symbol}</code>. <code>:simulate</code> triggers random draws of all shocks. Any shocks not part of the model will trigger a warning. <code>:none</code> in combination with an <code>initial_state</code> can be used for deterministic simulations.</li><li><code>negative_shock</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate a negative shock. Relevant for generalised IRFs.</li><li><code>generalised_irf</code> [Default: <code>false</code>, Type: <code>Bool</code>]: calculate generalised IRFs. Relevant for nonlinear solutions.</li><li><code>initial_state</code> [Default: <code>[0.0]</code>, Type: <code>Vector{Float64}</code>]: provide state from which to start IRFs. Relevant for normal IRFs.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end;

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end;

plot(RBC)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/plotting.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.plot_IRF" href="#MacroModelling.plot_IRF"><code>MacroModelling.plot_IRF</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.plot-Tuple{MacroModelling.‚Ñ≥}"><code>plot</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/plotting.jl#L245-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.plot_irf" href="#MacroModelling.plot_irf"><code>MacroModelling.plot_irf</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.plot-Tuple{MacroModelling.‚Ñ≥}"><code>plot</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/plotting.jl#L240-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.plot_irfs" href="#MacroModelling.plot_irfs"><code>MacroModelling.plot_irfs</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>See <a href="#MacroModelling.plot-Tuple{MacroModelling.‚Ñ≥}"><code>plot</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/plotting.jl#L251-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.plot_simulations-Tuple" href="#MacroModelling.plot_simulations-Tuple"><code>MacroModelling.plot_simulations</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.plot-Tuple{MacroModelling.‚Ñ≥}"><code>plot</code></a> with <code>shocks = :simulate</code> and <code>periods = 100</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/plotting.jl#L257-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.simulate-Tuple" href="#MacroModelling.simulate-Tuple"><code>MacroModelling.simulate</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Wrapper for <a href="#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}"><code>get_irf</code></a> with <code>shocks = :simulate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/get_functions.jl#L234-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.@model-Tuple{Any, Any}" href="#MacroModelling.@model-Tuple{Any, Any}"><code>MacroModelling.@model</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><p>Parses the model equations and assigns them to an object.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: name of the object to be created containing the model information.</li><li><code>ex</code>: equations</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/macros.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroModelling.@parameters-Tuple{Any, Any}" href="#MacroModelling.@parameters-Tuple{Any, Any}"><code>MacroModelling.@parameters</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><p>Adds parameter values and calibration equations to the previously defined model.</p><p><strong>Arguments</strong></p><ul><li><code>ùìÇ</code>: name of the object previously created containing the model information.</li><li><code>ex</code>: parameter, parameters values, and calibration equations</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MacroModelling

@model RBC begin
    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^Œ±
    z[0] = œÅ * z[-1] + std_z * eps_z[x]
end

@parameters RBC begin
    std_z = 0.01
    œÅ = 0.2
    Œ¥ = 0.02
    Œ± = 0.5
    Œ≤ = 0.95
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thorek1/MacroModelling.jl/blob/2cddc2babc07c9905d2b5dea086268fb47bd1a41/src/macros.jl#L832">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/sw03/">¬´ Smets and Wouters (2003)</a><a class="docs-footer-nextpage" href="../call_index/">Index ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 2 December 2022 00:18">Friday 2 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
