var documenterSearchIndex = {"docs":
[{"location":"unfinished_docs/how_to/#Use-calibration-equations","page":"-","title":"Use calibration equations","text":"","category":"section"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"Next we need to add the parameters of the model. The macro @parameters <name of the model> takes care of this:","category":"page"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend","category":"page"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"No need for line endings. If you want to define a parameter as a function of another parameter you can do this:","category":"page"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    beta1 = 1\n    beta2 = .95\n    Œ≤ | Œ≤ = beta2/beta1\nend","category":"page"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"Note that the parser takes parameters assigned to a numerical value first and then solves for the parameters defined by relationships: Œ≤ | .... This means also the following will work:","category":"page"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"@parameters RBC begin\n    Œ≤ | Œ≤ = beta2/beta1\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    beta1 = 1\n    beta2 = .95\nend","category":"page"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"More interestingly one can use (non-stochastic) steady state values in the relationships:","category":"page"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"@parameters RBC begin\n    Œ≤ = .95\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± | k[ss] / (4 * q[ss]) = 1.5\nend","category":"page"},{"location":"unfinished_docs/how_to/#Higher-order-perturbation-solutions","page":"-","title":"Higher order perturbation solutions","text":"","category":"section"},{"location":"unfinished_docs/how_to/#How-to-estimate-a-model","page":"-","title":"How to estimate a model","text":"","category":"section"},{"location":"unfinished_docs/how_to/#Interactive-plotting","page":"-","title":"Interactive plotting","text":"","category":"section"},{"location":"call_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"call_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MacroModelling]\nOrder   = [:function, :macro]","category":"page"},{"location":"api/#MacroModelling.get_IRF","page":"API","title":"MacroModelling.get_IRF","text":"See get_irf\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_SS","page":"API","title":"MacroModelling.get_SS","text":"See get_steady_state\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_first_order_solution","page":"API","title":"MacroModelling.get_first_order_solution","text":"See get_solution\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}","page":"API","title":"MacroModelling.get_irf","text":"get_irf(\n    ùìÇ,\n    parameters;\n    periods,\n    variables,\n    shocks,\n    negative_shock,\n    initial_state,\n    levels\n)\n\n\nReturn impulse response functions (IRFs) of the model in a 3-dimensional array. Function to use when differentiating IRFs with repect to parameters.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\nparameters [Type: Vector]: Parameter values in alphabetical order (sorted by parameter name).\n\nKeyword Arguments\n\nperiods [Default: 40, Type: Int]: number of periods for which to calculate the IRFs\nvariables [Default: :all]: variables for which to calculate the IRFs. Inputs can be either a Symbol (e.g. :y or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol} or Vector{Symbol}. Any variables not part of the model will trigger a warning.\nshocks [Default: :all]: shocks for which to calculate the IRFs. Inputs can be either a Symbol (e.g. :y, :simulate, :none, or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol} or Vector{Symbol}. :simulate triggers random draws of all shocks. Any shocks not part of the model will trigger a warning. :none in combination with an initial_state can be used for deterministic simulations.\nnegative_shock [Default: false, Type: Bool]: calculate a negative shock. Relevant for generalised IRFs.\ngeneralised_irf [Default: false, Type: Bool]: calculate generalised IRFs. Relevant for nonlinear solutions. Reference steady state for deviations is the stochastic steady state.\ninitial_state [Default: [0.0], Type: Vector{Float64}]: provide state from which to start IRFs. Relevant for normal IRFs.\nlevels [Default: false, Type: Bool]: return levels or absolute deviations from steady state\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nget_irf(RBC, RBC.parameter_values)\n# output\n4√ó40√ó1 Array{Float64, 3}:\n[:, :, 1] =\n 0.00674687  0.00729773  0.00715114  0.00687615  ‚Ä¶  0.00146962   0.00140619\n 0.0620937   0.0718322   0.0712153   0.0686381      0.0146789    0.0140453\n 0.0688406   0.0182781   0.00797091  0.0057232      0.00111425   0.00106615\n 0.01        0.002       0.0004      8.0e-5         2.74878e-29  5.49756e-30\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.get_irf","text":"get_irf(\n    ùìÇ;\n    periods,\n    algorithm,\n    parameters,\n    variables,\n    shocks,\n    negative_shock,\n    generalised_irf,\n    initial_state,\n    levels\n)\n\n\nReturn impulse response functions (IRFs) of the model in a 3-dimensional KeyedArray\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nperiods [Default: 40, Type: Int]: number of periods for which to calculate the IRFs\nalgorithm [Default: :first_order, Type: Symbol]: solution algorithm for which to show the IRFs\nparameters : If nothing is provided, the solution is calculated for the parameters defined previously. If a vector with parameter values, or a named tuple is provided and the parameters differ from the previously defined the solution will be recalculated. \nvariables [Default: :all]: variables for which to calculate the IRFs. Inputs can be either a Symbol (e.g. :y or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol} or Vector{Symbol}. Any variables not part of the model will trigger a warning.\nshocks [Default: :all]: shocks for which to calculate the IRFs. Inputs can be either a Symbol (e.g. :y, :simulate, :none, or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol} or Vector{Symbol}. :simulate triggers random draws of all shocks. Any shocks not part of the model will trigger a warning. :none in combination with an initial_state can be used for deterministic simulations.\nnegative_shock [Default: false, Type: Bool]: calculate a negative shock. Relevant for generalised IRFs.\ngeneralised_irf [Default: false, Type: Bool]: calculate generalised IRFs. Relevant for nonlinear solutions. Reference steady state for deviations is the stochastic steady state.\ninitial_state [Default: [0.0], Type: Vector{Float64}]: provide state from which to start IRFs. Relevant for normal IRFs.\nlevels [Default: false, Type: Bool]: return levels or absolute deviations from steady state\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nget_irf(RBC)\n# output\n3-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Variables ‚àà 4-element Vector{Symbol}\n‚Üí   Period ‚àà 40-element UnitRange{Int64}\n‚ó™   Shock ‚àà 1-element Vector{Symbol}\nAnd data, 4√ó40√ó1 Array{Float64, 3}:\n[:, :, 1] ~ (:, :, :eps_z):\n        (1)           (2)           ‚Ä¶  (39)            (40)\n  (:c)    0.00674687    0.00729773        0.00146962      0.00140619\n  (:k)    0.0620937     0.0718322         0.0146789       0.0140453\n  (:q)    0.0688406     0.0182781         0.00111425      0.00106615\n  (:z)    0.01          0.002             2.74878e-29     5.49756e-30\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_irfs","page":"API","title":"MacroModelling.get_irfs","text":"See get_irf\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥, Vector}","page":"API","title":"MacroModelling.get_moments","text":"get_moments(\n    ùìÇ,\n    parameters;\n    non_stochastic_steady_state,\n    standard_deviation,\n    variance,\n    covariance\n)\n\n\nReturn the first and second moments of endogenous variables using the linearised solution. By default returns: non stochastic steady state (SS), and standard deviations, but can also return variances, and covariance matrix. Function to use when differentiating model moments with repect to parameters.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\nparameters [Type: Vector]: Parameter values in alphabetical order (sorted by parameter name).\n\nKeyword Arguments\n\nnon_stochastic_steady_state [Default: true, Type: Bool]: switch to return SS of endogenous variables\nstandard_deviation [Default: true, Type: Bool]: switch to return standard deviation of endogenous variables\nvariance [Default: false, Type: Bool]: switch to return variance of endogenous variables\ncovariance [Default: false, Type: Bool]: switch to return covariance matrix of endogenous variables\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nget_moments(RBC, RBC.parameter_values)\n# output\n2-element Vector{Any}:\n [5.936252888048724, 47.39025414828808, 6.884057971014486, 0.0]\n [0.02666420378525522, 0.26467737291222343, 0.07393254045396495, 0.010206207261596576]\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.get_moments","text":"get_moments(\n    ùìÇ;\n    parameters,\n    non_stochastic_steady_state,\n    standard_deviation,\n    variance,\n    covariance,\n    derivatives,\n    parameter_derivatives\n)\n\n\nReturn the first and second moments of endogenous variables using the linearised solution. By default returns: non stochastic steady state (SS), and standard deviations, but can also return variances, and covariance matrix. Function to use when differentiating model moments with repect to parameters.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nparameters : If nothing is provided, the solution is calculated for the parameters defined previously. If a vector with parameter values, or a named tuple is provided and the parameters differ from the previously defined the solution will be recalculated. \nnon_stochastic_steady_state [Default: true, Type: Bool]: switch to return SS of endogenous variables\nstandard_deviation [Default: true, Type: Bool]: switch to return standard deviation of endogenous variables\nvariance [Default: false, Type: Bool]: switch to return variance of endogenous variables\ncovariance [Default: false, Type: Bool]: switch to return covariance matrix of endogenous variables\nderivatives [Default: true, Type: Bool]: switch to calculate derivatives of SS, standard deviation, and variance with respect to the parameters\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nmoments = get_moments(RBC);\n\nmoments[1]\n# output\n2-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Variables ‚àà 4-element Vector{Symbol}\n‚Üí   Steady_state_and_‚àÇsteady_state‚àÇparameter ‚àà 6-element Vector{Symbol}\nAnd data, 4√ó6 Matrix{Float64}:\n        (:Steady_state)  (:std_z)  (:œÅ)     (:Œ¥)      (:Œ±)       (:Œ≤)\n  (:c)   5.93625          0.0       0.0   -116.072    55.786     76.1014\n  (:k)  47.3903           0.0       0.0  -1304.95    555.264   1445.93\n  (:q)   6.88406          0.0       0.0    -94.7805   66.8912   105.02\n  (:z)   0.0              0.0       0.0      0.0       0.0        0.0\n\nmoments[2]\n# output\n2-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Variables ‚àà 4-element Vector{Symbol}\n‚Üí   Standard_deviation_and_‚àÇstandard_deviation‚àÇparameter ‚àà 6-element Vector{Symbol}\nAnd data, 4√ó6 Matrix{Float64}:\n        (:Standard_deviation)  (:std_z)  ‚Ä¶  (:Œ¥)       (:Œ±)       (:Œ≤)\n  (:c)   0.0266642              2.66642     -0.384359   0.2626     0.144789\n  (:k)   0.264677              26.4677      -5.74194    2.99332    6.30323\n  (:q)   0.0739325              7.39325     -0.974722   0.726551   1.08\n  (:z)   0.0102062              1.02062      0.0        0.0        0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_non_stochastic_steady_state-Tuple","page":"API","title":"MacroModelling.get_non_stochastic_steady_state","text":"Wrapper for get_steady_state with stochastic = false.\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_perturbation_solution","page":"API","title":"MacroModelling.get_perturbation_solution","text":"See get_solution\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.get_solution","text":"get_solution(ùìÇ; parameters)\n\n\nReturn the linearised solution and the non stochastic steady state (SS) of the model.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nparameters : If nothing is provided, the solution is calculated for the parameters defined previously. If a vector with parameter values, or a named tuple is provided and the parameters differ from the previously defined the solution will be recalculated. \n\nThe returned KeyedArray shows the SS, policy and transition functions of the model. The columns show the varibales including auxilliary endogenous and exogenous variables (due to leads and lags > 1). The rows are the SS, followed by the states, and exogenous shocks.  Subscripts following variable names indicate the timing (e.g. variable‚Çç‚Çã‚ÇÅ‚Çé  indicates the variable being in the past). Superscripts indicate leads or lags (e.g. variable·¥∏‚ÅΩ¬≤‚Åæ indicates the variable being in lead by two periods). If no super- or subscripts follow the variable name, the variable is in the present.\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nget_solution(RBC)\n# output\n2-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Steady_state__States__Shocks ‚àà 4-element Vector{Symbol}\n‚Üí   Variable ‚àà 4-element Vector{Symbol}\nAnd data, 4√ó4 adjoint(::Matrix{Float64}) with eltype Float64:\n                   (:c)         (:k)        (:q)        (:z)\n  (:Steady_state)   5.93625     47.3903      6.88406     0.0\n  (:k‚Çç‚Çã‚ÇÅ‚Çé)          0.0957964    0.956835    0.0726316  -0.0\n  (:z‚Çç‚Çã‚ÇÅ‚Çé)          0.134937     1.24187     1.37681     0.2\n  (:eps_z‚Çç‚Çì‚Çé)       0.00674687   0.0620937   0.0688406   0.01\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.get_steady_state","text":"get_steady_state(\n    ùìÇ;\n    parameters,\n    derivatives,\n    stochastic,\n    parameter_derivatives\n)\n\n\nReturn the (non stochastic) steady state and derivatives with respect to model parameters.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nparameters : If nothing is provided, the solution is calculated for the parameters defined previously. If a vector with parameter values, or a named tuple is provided and the parameters differ from the previously defined the solution will be recalculated. \nderivatives [Default: true, Type: Bool]: calculate derivatives of the SS with respect to the parameters\nstochastic [Default: false, Type: Bool]: return stochastic steady state using second order perturbation. No derivatives are calculated.\n\nThe columns show the SS and parameters for which derivatives are taken. The rows show the variables.\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nget_steady_state(RBC)\n# output\n2-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Variables_and_calibrated_parameters ‚àà 4-element Vector{Symbol}\n‚Üí   Steady_state_and_‚àÇsteady_state‚àÇparameter ‚àà 6-element Vector{Symbol}\nAnd data, 4√ó6 Matrix{Float64}:\n        (:Steady_state)  (:std_z)  (:œÅ)     (:Œ¥)      (:Œ±)       (:Œ≤)\n  (:c)   5.93625          0.0       0.0   -116.072    55.786     76.1014\n  (:k)  47.3903           0.0       0.0  -1304.95    555.264   1445.93\n  (:q)   6.88406          0.0       0.0    -94.7805   66.8912   105.02\n  (:z)   0.0              0.0       0.0      0.0       0.0        0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_stochastic_steady_state-Tuple","page":"API","title":"MacroModelling.get_stochastic_steady_state","text":"Wrapper for get_steady_state with stochastic = true.\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.plot-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.plot","text":"plot(\n    ùìÇ;\n    periods,\n    shocks,\n    variables,\n    parameters,\n    show_plots,\n    save_plots,\n    save_plots_format,\n    save_plots_path,\n    plots_per_page,\n    algorithm,\n    negative_shock,\n    generalised_irf,\n    initial_state\n)\n\n\nPlot impulse response functions (IRFs) of the model.\n\nThe left axis shows the level, and the right the deviation from the reference steady state. Linear solutions have the non stochastic steady state as reference other solutoin the stochastic steady state. The horizontal black line indicates the reference steady state. Variable names are above the subplots and the title provides information about the model, shocks and number of pages per shock.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nplots_per_page [Default: 9, Type: Int]: how many plots to show per page\nsave_plots [Default: false, Type: Bool]: switch to save plots using path and extension from save_plots_path and save_plots_format. Separate files per shocks and variables depending on number of variables and plots_per_page\nsave_plots_path [Default: pwd(), Type: String]: path where to save plots\nsave_plots_format [Default: :pdf, Type: Symbol]: output format of saved plots. See input formats compatible with GR for valid formats.\nshow_plots [Default: true, Type: Bool]: show plots. Separate plots per shocks and varibles depending on number of variables and plots_per_page.\nperiods [Default: 40, Type: Int]: number of periods for which to calculate the IRFs\nalgorithm [Default: :first_order, Type: Symbol]: solution algorithm for which to show the IRFs\nparameters : If nothing is provided, the solution is calculated for the parameters defined previously. If a vector with parameter values, or a named tuple is provided and the parameters differ from the previously defined the solution will be recalculated. \nvariables [Default: :all]: variables for which to calculate the IRFs. Inputs can be either a Symbol (e.g. :y or :all), Matrix{Symbol} or Vector{Symbol}. Any variables not part of the model will trigger a warning.\nshocks [Default: :all]: shocks for which to calculate the IRFs. Inputs can be either a Symbol (e.g. :y, :simulate, :none, or :all), Matrix{Symbol} or Vector{Symbol}. :simulate triggers random draws of all shocks. Any shocks not part of the model will trigger a warning. :none in combination with an initial_state can be used for deterministic simulations.\nnegative_shock [Default: false, Type: Bool]: calculate a negative shock. Relevant for generalised IRFs.\ngeneralised_irf [Default: false, Type: Bool]: calculate generalised IRFs. Relevant for nonlinear solutions.\ninitial_state [Default: [0.0], Type: Vector{Float64}]: provide state from which to start IRFs. Relevant for normal IRFs.\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nplot(RBC)\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.plot_IRF","page":"API","title":"MacroModelling.plot_IRF","text":"See plot\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.plot_irf","page":"API","title":"MacroModelling.plot_irf","text":"See plot\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.plot_irfs","page":"API","title":"MacroModelling.plot_irfs","text":"See plot\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.plot_simulations-Tuple","page":"API","title":"MacroModelling.plot_simulations","text":"Wrapper for plot with shocks = :simulate and periods = 100.\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.simulate-Tuple","page":"API","title":"MacroModelling.simulate","text":"Wrapper for get_irf with shocks = :simulate.\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.@model-Tuple{Any, Any}","page":"API","title":"MacroModelling.@model","text":"Parses the model equations and assigns them to an object.\n\nArguments\n\nùìÇ: name of the object to be created containing the model information.\nex: equations\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/#MacroModelling.@parameters-Tuple{Any, Any}","page":"API","title":"MacroModelling.@parameters","text":"Adds parameter values and calibration equations to the previously defined model.\n\nArguments\n\nùìÇ: name of the object previously created containing the model information.\nex: parameter, parameters values, and calibration equations\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend\n\n\n\n\n\n","category":"macro"},{"location":"tutorials/install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"tutorials/install/","page":"Installation","title":"Installation","text":"MacroModelling.jl requires julia version 1.8 or higher and an IDE is recommended (e.g. VS Code with the julia extension).","category":"page"},{"location":"tutorials/install/","page":"Installation","title":"Installation","text":"Once set up you can install MacroModelling.jl by typing the following in the julia REPL:","category":"page"},{"location":"tutorials/install/","page":"Installation","title":"Installation","text":"using Pkg; Pkg.add(\"MacroModelling\")","category":"page"},{"location":"unfinished_docs/todo/#Todo-list:","page":"Todo list:","title":"Todo list:","text":"","category":"section"},{"location":"unfinished_docs/todo/#High-priority:","page":"Todo list:","title":"High priority:","text":"","category":"section"},{"location":"unfinished_docs/todo/","page":"Todo list:","title":"Todo list:","text":"[x] Get functions: getoutput, getmoments\n[x] estimation, IRF matching, system priors\n[x] check derivative tests with finite diff\n[ ] clean up printouts/reporting\n[ ] release first version\n[ ] clean up function inputs and harmonise AD and standard commands\n[ ] figure out combinations for inputs (parameters and variables in different formats for get_irf for example) \n[ ] write documentation/docstrings\n[ ] revisit optimizers for SS\n[ ] write tests and documentation for solution, estimation... making sure results are consistent\n[ ] figure out licenses\n[ ] add more models\n[ ] symbolic derivatives\n[ ] use @assert for errors or maybe argcheck\n[ ] print SS dependencies, show SS solver\n[ ] an and schorfheide estimation\n[ ] SS: replace variables in log() with auxilliary variable which must be positive to help solver\n[ ] plot multiple solutions or models - multioptions in one graph\n[ ] add correlation, autocorrelation, and variance decomposition","category":"page"},{"location":"unfinished_docs/todo/#Not-high-priority:","page":"Todo list:","title":"Not high priority:","text":"","category":"section"},{"location":"unfinished_docs/todo/","page":"Todo list:","title":"Todo list:","text":"[x] implement blockdiag with julia package instead of python\n[ ] estimation codes with missing values (adopt kalman filter)\n[ ] whats a good error measure for higher order solutions (taking whole dist of future shock into account)? use mean error for n number of future shocks\n[ ] implement global solution methods\n[ ] more options for IRFs, pass on shock vector, simulate only certain shocks\n[ ] improve redundant calculations of SS and other parts of solution\n[ ] find way to recover from failed SS solution which is written to init guess\n[ ] restructure functions and containers so that compiler knows what types to expect\n[ ] use RecursiveFactorization and TriangularSolve to solve, instead of MKL or OpenBLAS\n[ ] fix SnoopCompile with generated functions\n[ ] rewrite first order with riccati equation MatrixEquations.jl\n[ ] exploit variable incidence and compression for derivatives\n[ ] for estimation use CUDA with st order: linear time iteration starting from last 1st order solution and then LinearSolveCUDA solvers for higher orders. this should bring benefits for large models and HANK models\n[ ] test on highly nonlinear model (https://www.sciencedirect.com/science/article/pii/S0165188917300970)\n[ ] pull request in StatsFuns to have norminv... accept type numbers and add translation from matlab: norminv to StatsFuns norminvcdf\n[ ] conditions for when to use which solution. if solution is outdated redo all solutions which have been done so far and use smart starting points\n[ ] more informative errors when declaring equations/ calibration\n[ ] unit equation errors\n[ ] implenent reduced linearised system solver + nonlinear\n[ ] implement HANK\n[ ] implement automatic problem derivation (gEcon)\n[ ] write to dynare\n[ ] print legend for algorithm in last subplot of plot only\n[ ] conditional forecasting\n[ ] speed up 2nd moment calc for large models. maybe its only the derivatives but its slow for SW03\n[ ] redo ugly solution for selecting parameters to differentiate for\n[ ] select variables for moments\n[x] Revise 2,3 pert codes to make it more intuitive \n[x] Pretty print linear solution\n[x] write function to get_irfs\n[x] Named arrays for irf\n[x] write state space function for solution\n[x] Status print for model container\n[x] implenent 2nd + 3rd order perturbation\n[x] implement fuctions for distributions\n[x] try speedmapping.jl - no improvement\n[x] moment matching\n[x] write tests for higher order pert and standalone function\n[x] add compression back in\n[x] FixedPointAcceleration didnt improve on iterative procedure\n[x] add exogenous variables in lead or lag\n[x] regex in parser of SS and exo\n[x] test SS solver on SW07\n[x] change calibration, distinguish SS/dyn parameters\n[x] plot multiple solutions at same time (save them in separate constructs)\n[x] implement bounds in SS finder\n[x] map pars + vars impacting SS\n[x] check bounds when putting in new calibration\n[x] Save plot option\n[x] Add shock to plot title\n[x] print model name","category":"page"},{"location":"tutorials/rbc/#Write-your-first-model-simple-RBC","page":"RBC","title":"Write your first model - simple RBC","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The following tutorial will walk you through the steps of writing down a model (not explained here / taken as given) and analysing it. Prior knowledge of DSGE models and their solution in practical terms (e.g. having used a mod file with dynare) is useful in understanding this tutorial.","category":"page"},{"location":"tutorials/rbc/#Define-the-model","page":"RBC","title":"Define the model","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The first step is always to name the model and write down the equations. Taking a standard real business cycle (RBC) model this would go as follows:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"ENV[\"GKSwstype\"] = \"100\"","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"using MacroModelling\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"First, we load the package and then use the @model macro to define our model. The first argument after @model is the model name and will be the name of the object in the global environment containing all information regarding the model. The second argument to the macro are the equations, which we write down between begin and end. One equation per line and timing of endogenous variables are expressed in the squared brackets following the variable name. Exogenous variables (shocks) are followed by a keyword in squared brackets indicating them being exogenous (in this case [x]). Note that names can leverage julias unicode capabilities (alpha can be written as Œ±).","category":"page"},{"location":"tutorials/rbc/#Define-the-parameters","page":"RBC","title":"Define the parameters","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Next we need to add the parameters of the model. The macro @parameters takes care of this:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Parameter definitions are similar to assigning values in julia. Note that we have to write one parameter definition per line.","category":"page"},{"location":"tutorials/rbc/#Plot-impulse-response-functions-(IRFs)","page":"RBC","title":"Plot impulse response functions (IRFs)","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Given the equations and parameters, we have everything to solve the model and do some analysis. A common output are IRFs for the exogenous shocks. Calling plot_irf (different names for the same function are also supported: plot_irfs, plot_IRF, or simply plot) will take care of this. In the background the package solves (symbolically in this simple case) for the non stochastic steady state (SS) and calculates the first order perturbation solution.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"plot_irf(RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"(Image: RBC IRF)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The plot shows the responses of the endogenous variables (c, k, q, and z) to a one standard deviation positive (indicated by Shock‚Å∫ in chart title) unanticipated shock in  eps_z. Therefore there are as many subplots as there are combinations of shocks and endogenous variables (which are impacted by the shock). Plots are composed of up to 9 subplots and the plot title shows the model name followed by the name of the shock and which plot we are seeing out of the plots for this shock (e.g. (1/3) means we see the first out of three plots for this shock). Subplots show the sorted endogenous variables with the left y-axis showing the level of the respective variable and the right y-axis showing the percent deviation from the SS (if variable is strictly positive). The horizontal black line marks the SS.","category":"page"},{"location":"tutorials/rbc/#Explore-other-parameter-values","page":"RBC","title":"Explore other parameter values","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Playing around with the model is especially insightful in the early phase of model development. The package facilitates this process to the extent possible. Typically one wants to try different parameter values and see how the IRFs change. This can be done by using the parameters argument of the plot_irf function. We pass a Pair with the Symbol of the parameter (: in front of the parameter name) we want to change and its new value to the parameter argument (e.g. :Œ± => 0.3).","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"plot_irf(RBC, parameters = :Œ± => 0.3)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"(Image: )","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"First, the package tells us which parameters changed and that this also changed the steady state. The new SS and model solution are permanently saved in the model object. Second, note that the shape of the curves in the plot and the y-axis values changed. What happened in the background is that the package recalculated the SS and solved the model around the new SS. Updating the plot for new parameters is significantly faster than calling it the first time. This is because the first call triggers compilations of the model functions, and once compiled the user benefits from the performance of the specialised compiled code.","category":"page"},{"location":"tutorials/rbc/#Plot-model-simulation","page":"RBC","title":"Plot model simulation","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Another insightful output is simulations of the model. Here we can use the plot_simulations function. To the same effect we can use the plot function and specify in the shocks argument that we want to :simulate the model and set the periods argument to 100.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"plot_simulations(RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"(Image: Simulate RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The plots show the models endogenous variables in response to random draws for all exogenous shocks over 100 periods.","category":"page"},{"location":"tutorials/rbc/#Steady-state-and-model-implied-standard-deviations","page":"RBC","title":"Steady state and model implied standard deviations","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The package solves for the SS automatically and we got an idea of the SS values in the plots. If we want to see the SS values we can call get_steady_state:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"get_steady_state(RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"to get the SS and the derivatives of the SS with respect to the model parameters. The first column of the returned matrix shows the SS while the second to last columns show the derivatives of the SS values (indicated in the rows) with respect to the parameters (indicated in the columns). For example, the derivative of k with respect to Œ≤ is 165.319. This means that if we increase Œ≤ by 1, k would increase by 165.319 approximately. Let's see how this plays out by changing Œ≤ from 0.95 to 0.951 (a change of +0.001):","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"get_steady_state(RBC,parameters = :Œ≤ => .951)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Note that get_steady_state like all other get functions has the parameters argument. Hence, whatever output we are looking at we can change the parameters of the model. ","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The new value of Œ≤ changed the SS as expected and k increased by 0.168. The elasticity (0.168/0.001) comes close to the partial derivative previously calculated. The derivatives help understanding the effect of parameter changes on the steady state and make for easier navigation of the parameter space.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Next to the SS we can also show the model implied standard deviations of the model. get_moments takes care of this. Additionally we will set the parameter values to what they were in the beginning by passing on a Tuple of Pairs containing the Symbols of the parameters to be changed and their new (initial) values (e.g. (:Œ± => 0.5, :Œ≤ => .95)).","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"moments = get_moments(RBC, parameters = (:Œ± => 0.5, :Œ≤ => .95));\nmoments[1]\nmoments[2]","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The first element returned by get_moments is the SS and identical to what we would get by calling get_steady_state. The second element contains the model implied standard deviations of the model variables and their derivatives with respect to the model parameters. For example, the derivative of the standard deviation of c with resect to Œ¥ is -0.384. In other words, the standard deviation of c decreases with increasing Œ¥.","category":"page"},{"location":"tutorials/rbc/#Model-solution-(policy-and-transition-function)","page":"RBC","title":"Model solution (policy and transition function)","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"A further insightful output are the policy and transition functions of the the first order perturbation solution. To retrieve the solution we call the function get_solution:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"get_solution(RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The solution provides information about how past states and present shocks impact present variables. The first row contains the SS for the variables denoted in the columns. The second to last rows contain the past states, with the time index ‚Çç‚Çã‚ÇÅ‚Çé, and present shocks, with exogenous variables denoted by ‚Çç‚Çì‚Çé. For example, the immediate impact of a shock to eps_z on q is 0.0688. ","category":"page"},{"location":"tutorials/rbc/#Obtain-array-of-IRFs-or-model-simulations","page":"RBC","title":"Obtain array of IRFs or model simulations","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Last but not least the user might want to obtain simulated time series of the model or IRFs without plotting them. For IRFs this is possible by calling get_irf:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"get_irf(RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"which returns a 3-dimensional KeyedArray with variables in rows, the period in columns, and the shocks as the third dimension.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"For simulations this is possible by calling simulate:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"simulate(RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"which returns the simulated data in a 3-dimensional KeyedArray of the same structure as for the IRFs.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"MacroModelling.jl enables fast prototyping of dynamic stochastic general equilibrium (DSGE) models","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The package currently supports dicsrete-time DSGE models and the timing of a variable reflects when the variable is decided (end of period for stock variables).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As of now the package can:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"parse a model written with user friendly syntax (variables are followed by time indices ...[2], [1], [0], [-1], [-2]..., or [x] for shocks)\n(tries to) solve the model only knowing the model equations and parameter values (no steady state file needed)\ncalculate first, second, and third order perturbation solutions using (forward) automatic differentiation (AD)\ncalculate (generalised) impulse response functions, and simulate the model\ncalibrate parameters using (non stochastic) steady state relationships\nmatch model moments\nestimate the model on data (kalman filter using first order perturbation)\ndifferentiate (forward AD) the model solution (first order perturbation), kalman filter loglikelihood, model moments, steady state, with respect to the parameters","category":"page"},{"location":"tutorials/sw03/#Work-with-a-complex-model-Smets-and-Wouters-(2003)","page":"Smets and Wouters (2003)","title":"Work with a complex model - Smets and Wouters (2003)","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"This tutorial is intended to show more advanced features of the package which come into play with more complex models. The tutorial will walk through the same steps as for the simple RBC model but will use the nonlinear Smets and Wouters (2003) model instead. Prior knowledge of DSGE models and their solution in practical terms (e.g. having used a mod file with dynare) is useful in understanding this tutorial.","category":"page"},{"location":"tutorials/sw03/#Define-the-model","page":"Smets and Wouters (2003)","title":"Define the model","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The first step is always to name the model and write down the equations. For the Smets and Wouters (2003) model this would go as follows:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"ENV[\"GKSwstype\"] = \"100\"","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"using MacroModelling\n@model SW03 begin\n    -q[0] + beta * ((1 - tau) * q[1] + epsilon_b[1] * (r_k[1] * z[1] - psi^-1 * r_k[ss] * (-1 + exp(psi * (-1 + z[1])))) * (C[1] - h * C[0])^(-sigma_c))\n    -q_f[0] + beta * ((1 - tau) * q_f[1] + epsilon_b[1] * (r_k_f[1] * z_f[1] - psi^-1 * r_k_f[ss] * (-1 + exp(psi * (-1 + z_f[1])))) * (C_f[1] - h * C_f[0])^(-sigma_c))\n    -r_k[0] + alpha * epsilon_a[0] * mc[0] * L[0]^(1 - alpha) * (K[-1] * z[0])^(-1 + alpha)\n    -r_k_f[0] + alpha * epsilon_a[0] * mc_f[0] * L_f[0]^(1 - alpha) * (K_f[-1] * z_f[0])^(-1 + alpha)\n    -G[0] + T[0]\n    -G[0] + G_bar * epsilon_G[0]\n    -G_f[0] + T_f[0]\n    -G_f[0] + G_bar * epsilon_G[0]\n    -L[0] + nu_w[0]^-1 * L_s[0]\n    -L_s_f[0] + L_f[0] * (W_i_f[0] * W_f[0]^-1)^(lambda_w^-1 * (-1 - lambda_w))\n    L_s_f[0] - L_f[0]\n    L_s_f[0] + lambda_w^-1 * L_f[0] * W_f[0]^-1 * (-1 - lambda_w) * (-W_disutil_f[0] + W_i_f[0]) * (W_i_f[0] * W_f[0]^-1)^(-1 + lambda_w^-1 * (-1 - lambda_w))\n    Pi_ws_f[0] - L_s_f[0] * (-W_disutil_f[0] + W_i_f[0])\n    Pi_ps_f[0] - Y_f[0] * (-mc_f[0] + P_j_f[0]) * P_j_f[0]^(-lambda_p^-1 * (1 + lambda_p))\n    -Q[0] + epsilon_b[0]^-1 * q[0] * (C[0] - h * C[-1])^(sigma_c)\n    -Q_f[0] + epsilon_b[0]^-1 * q_f[0] * (C_f[0] - h * C_f[-1])^(sigma_c)\n    -W[0] + epsilon_a[0] * mc[0] * (1 - alpha) * L[0]^(-alpha) * (K[-1] * z[0])^alpha\n    -W_f[0] + epsilon_a[0] * mc_f[0] * (1 - alpha) * L_f[0]^(-alpha) * (K_f[-1] * z_f[0])^alpha\n    -Y_f[0] + Y_s_f[0]\n    Y_s[0] - nu_p[0] * Y[0]\n    -Y_s_f[0] + Y_f[0] * P_j_f[0]^(-lambda_p^-1 * (1 + lambda_p))\n    beta * epsilon_b[1] * (C_f[1] - h * C_f[0])^(-sigma_c) - epsilon_b[0] * R_f[0]^-1 * (C_f[0] - h * C_f[-1])^(-sigma_c)\n    beta * epsilon_b[1] * pi[1]^-1 * (C[1] - h * C[0])^(-sigma_c) - epsilon_b[0] * R[0]^-1 * (C[0] - h * C[-1])^(-sigma_c)\n    Y_f[0] * P_j_f[0]^(-lambda_p^-1 * (1 + lambda_p)) - lambda_p^-1 * Y_f[0] * (1 + lambda_p) * (-mc_f[0] + P_j_f[0]) * P_j_f[0]^(-1 - lambda_p^-1 * (1 + lambda_p))\n    epsilon_b[0] * W_disutil_f[0] * (C_f[0] - h * C_f[-1])^(-sigma_c) - omega * epsilon_b[0] * epsilon_L[0] * L_s_f[0]^sigma_l\n    -1 + xi_p * (pi[0]^-1 * pi[-1]^gamma_p)^(-lambda_p^-1) + (1 - xi_p) * pi_star[0]^(-lambda_p^-1)\n    -1 + (1 - xi_w) * (w_star[0] * W[0]^-1)^(-lambda_w^-1) + xi_w * (W[-1] * W[0]^-1)^(-lambda_w^-1) * (pi[0]^-1 * pi[-1]^gamma_w)^(-lambda_w^-1)\n    -Phi - Y_s[0] + epsilon_a[0] * L[0]^(1 - alpha) * (K[-1] * z[0])^alpha\n    -Phi - Y_f[0] * P_j_f[0]^(-lambda_p^-1 * (1 + lambda_p)) + epsilon_a[0] * L_f[0]^(1 - alpha) * (K_f[-1] * z_f[0])^alpha\n    std_eta_b * eta_b[x] - log(epsilon_b[0]) + rho_b * log(epsilon_b[-1])\n    -std_eta_L * eta_L[x] - log(epsilon_L[0]) + rho_L * log(epsilon_L[-1])\n    std_eta_I * eta_I[x] - log(epsilon_I[0]) + rho_I * log(epsilon_I[-1])\n    std_eta_w * eta_w[x] - f_1[0] + f_2[0]\n    std_eta_a * eta_a[x] - log(epsilon_a[0]) + rho_a * log(epsilon_a[-1])\n    std_eta_p * eta_p[x] - g_1[0] + g_2[0] * (1 + lambda_p)\n    std_eta_G * eta_G[x] - log(epsilon_G[0]) + rho_G * log(epsilon_G[-1])\n    -f_1[0] + beta * xi_w * f_1[1] * (w_star[0]^-1 * w_star[1])^(lambda_w^-1) * (pi[1]^-1 * pi[0]^gamma_w)^(-lambda_w^-1) + epsilon_b[0] * w_star[0] * L[0] * (1 + lambda_w)^-1 * (C[0] - h * C[-1])^(-sigma_c) * (w_star[0] * W[0]^-1)^(-lambda_w^-1 * (1 + lambda_w))\n    -f_2[0] + beta * xi_w * f_2[1] * (w_star[0]^-1 * w_star[1])^(lambda_w^-1 * (1 + lambda_w) * (1 + sigma_l)) * (pi[1]^-1 * pi[0]^gamma_w)^(-lambda_w^-1 * (1 + lambda_w) * (1 + sigma_l)) + omega * epsilon_b[0] * epsilon_L[0] * (L[0] * (w_star[0] * W[0]^-1)^(-lambda_w^-1 * (1 + lambda_w)))^(1 + sigma_l)\n    -g_1[0] + beta * xi_p * pi_star[0] * g_1[1] * pi_star[1]^-1 * (pi[1]^-1 * pi[0]^gamma_p)^(-lambda_p^-1) + epsilon_b[0] * pi_star[0] * Y[0] * (C[0] - h * C[-1])^(-sigma_c)\n    -g_2[0] + beta * xi_p * g_2[1] * (pi[1]^-1 * pi[0]^gamma_p)^(-lambda_p^-1 * (1 + lambda_p)) + epsilon_b[0] * mc[0] * Y[0] * (C[0] - h * C[-1])^(-sigma_c)\n    -nu_w[0] + (1 - xi_w) * (w_star[0] * W[0]^-1)^(-lambda_w^-1 * (1 + lambda_w)) + xi_w * nu_w[-1] * (W[-1] * pi[0]^-1 * W[0]^-1 * pi[-1]^gamma_w)^(-lambda_w^-1 * (1 + lambda_w))\n    -nu_p[0] + (1 - xi_p) * pi_star[0]^(-lambda_p^-1 * (1 + lambda_p)) + xi_p * nu_p[-1] * (pi[0]^-1 * pi[-1]^gamma_p)^(-lambda_p^-1 * (1 + lambda_p))\n    -K[0] + K[-1] * (1 - tau) + I[0] * (1 - 0.5 * varphi * (-1 + I[-1]^-1 * epsilon_I[0] * I[0])^2)\n    -K_f[0] + K_f[-1] * (1 - tau) + I_f[0] * (1 - 0.5 * varphi * (-1 + I_f[-1]^-1 * epsilon_I[0] * I_f[0])^2)\n    U[0] - beta * U[1] - epsilon_b[0] * ((1 - sigma_c)^-1 * (C[0] - h * C[-1])^(1 - sigma_c) - omega * epsilon_L[0] * (1 + sigma_l)^-1 * L_s[0]^(1 + sigma_l))\n    U_f[0] - beta * U_f[1] - epsilon_b[0] * ((1 - sigma_c)^-1 * (C_f[0] - h * C_f[-1])^(1 - sigma_c) - omega * epsilon_L[0] * (1 + sigma_l)^-1 * L_s_f[0]^(1 + sigma_l))\n    -epsilon_b[0] * (C[0] - h * C[-1])^(-sigma_c) + q[0] * (1 - 0.5 * varphi * (-1 + I[-1]^-1 * epsilon_I[0] * I[0])^2 - varphi * I[-1]^-1 * epsilon_I[0] * I[0] * (-1 + I[-1]^-1 * epsilon_I[0] * I[0])) + beta * varphi * I[0]^-2 * epsilon_I[1] * q[1] * I[1]^2 * (-1 + I[0]^-1 * epsilon_I[1] * I[1])\n    -epsilon_b[0] * (C_f[0] - h * C_f[-1])^(-sigma_c) + q_f[0] * (1 - 0.5 * varphi * (-1 + I_f[-1]^-1 * epsilon_I[0] * I_f[0])^2 - varphi * I_f[-1]^-1 * epsilon_I[0] * I_f[0] * (-1 + I_f[-1]^-1 * epsilon_I[0] * I_f[0])) + beta * varphi * I_f[0]^-2 * epsilon_I[1] * q_f[1] * I_f[1]^2 * (-1 + I_f[0]^-1 * epsilon_I[1] * I_f[1])\n    std_eta_pi * eta_pi[x] - log(pi_obj[0]) + rho_pi_bar * log(pi_obj[-1]) + log(calibr_pi_obj) * (1 - rho_pi_bar)\n    -C[0] - I[0] - T[0] + Y[0] - psi^-1 * r_k[ss] * K[-1] * (-1 + exp(psi * (-1 + z[0])))\n    -calibr_pi + std_eta_R * eta_R[x] - log(R[ss]^-1 * R[0]) + r_Delta_pi * (-log(pi[ss]^-1 * pi[-1]) + log(pi[ss]^-1 * pi[0])) + r_Delta_y * (-log(Y[ss]^-1 * Y[-1]) + log(Y[ss]^-1 * Y[0]) + log(Y_f[ss]^-1 * Y_f[-1]) - log(Y_f[ss]^-1 * Y_f[0])) + rho * log(R[ss]^-1 * R[-1]) + (1 - rho) * (log(pi_obj[0]) + r_pi * (-log(pi_obj[0]) + log(pi[ss]^-1 * pi[-1])) + r_Y * (log(Y[ss]^-1 * Y[0]) - log(Y_f[ss]^-1 * Y_f[0])))\n    -C_f[0] - I_f[0] + Pi_ws_f[0] - T_f[0] + Y_f[0] + L_s_f[0] * W_disutil_f[0] - L_f[0] * W_f[0] - psi^-1 * r_k_f[ss] * K_f[-1] * (-1 + exp(psi * (-1 + z_f[0])))\n    epsilon_b[0] * (K[-1] * r_k[0] - r_k[ss] * K[-1] * exp(psi * (-1 + z[0]))) * (C[0] - h * C[-1])^(-sigma_c)\n    epsilon_b[0] * (K_f[-1] * r_k_f[0] - r_k_f[ss] * K_f[-1] * exp(psi * (-1 + z_f[0]))) * (C_f[0] - h * C_f[-1])^(-sigma_c)\nend","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"First, we load the package and then use the @model macro to define our model. The first argument after @model is the model name and will be the name of the object in the global environment containing all information regarding the model. The second argument to the macro are the equations, which we write down between begin and end. Equations can contain an equality sign or the expression is assumed to equal 0. Equations cannot span multiple lines and the timing of endogenous variables are expressed in the squared brackets following the variable name (e.g. [-1] for the past period). Exogenous variables (shocks) are followed by a keyword in squared brackets indicating them being exogenous (in this case [x]). In this example there are also variables in the non stochastic steady state denoted by [ss]. Note that names can leverage julia's unicode capabilities (alpha can be written as Œ±).","category":"page"},{"location":"tutorials/sw03/#Define-the-parameters","page":"Smets and Wouters (2003)","title":"Define the parameters","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Next we need to add the parameters of the model. The macro @parameters takes care of this:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"@parameters SW03 begin  \n    lambda_p = .368\n    G_bar = .362\n    lambda_w = 0.5\n    Phi = .819\n\n    alpha = 0.3\n    beta = 0.99\n    gamma_w = 0.763\n    gamma_p = 0.469\n    h = 0.573\n    omega = 1\n    psi = 0.169\n\n    r_pi = 1.684\n    r_Y = 0.099\n    r_Delta_pi = 0.14\n    r_Delta_y = 0.159\n\n    sigma_c = 1.353\n    sigma_l = 2.4\n    tau = 0.025\n    varphi = 6.771\n    xi_w = 0.737\n    xi_p = 0.908\n\n    rho = 0.961\n    rho_b = 0.855\n    rho_L = 0.889\n    rho_I = 0.927\n    rho_a = 0.823\n    rho_G = 0.949\n    rho_pi_bar = 0.924\n\n    std_eta_b = 0.336\n    std_eta_L = 3.52\n    std_eta_I = 0.085\n    std_eta_a = 0.598\n    std_eta_w = 0.6853261\n    std_eta_p = 0.7896512\n    std_eta_G = 0.325\n    std_eta_R = 0.081\n    std_eta_pi = 0.017\n\n    calibr_pi_obj | 1 = pi_obj[ss]\n    calibr_pi | pi[ss] = pi_obj[ss]\n    \n    # Putting non-negativity constraints on first block\n    0 < K\n    0 < I\n    0 < Y_s\n    0 < q\n    0 < r_k\n    0 < f_1\n    0 < L\n    0 < W\n    0 < g_1\n    0 < z\n    0 < mc\n    0 < w_star\n    0 < f_2\n    0 < Y\n    0 < g_2\n    0 < C\nend","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The block defining the parameters above has three different inputs. ","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"First, there are simple parameter definition the same way you assign values (e.g. Phi = .819). ","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Second, there are calibration equations where we treat the value of a parameter as unknown (e.g. calibr_pi_obj) and want an additional equation to hold (e.g. 1 = pi_obj[ss]). The additional equation can contain variables in SS or parameters. Putting it together a calibration equation is defined by the unknown parameter followed by | and the calibration equation (e.g. calibr_pi_obj | 1 = pi_obj[ss]).","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Third, information about the domain of variables and parameters are passed on (e.g. 0 < C). This is useful information for the symbolic and numerical solvers of the SS.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Note that we have to write one parameter definition per line.","category":"page"},{"location":"tutorials/sw03/#Plot-impulse-response-functions-(IRFs)","page":"Smets and Wouters (2003)","title":"Plot impulse response functions (IRFs)","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Given the equations and parameters, we have everything to solve the model and do some analysis. A common output are IRFs for the exogenous shocks. Calling plot_irf (different names for the same function are also supported: plot_irfs, plot_IRF, or simply plot) will take care of this. In the background the package solves (numerically in this complex case) for the non stochastic steady state (SS) and calculates the first order perturbation solution.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"plot_irf(SW03)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"(Image: RBC IRF)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"When the model is solved the first time (in this case by calling plot_irf), the SS is first attempted to be solved symbolically and if that fails numerically. Here the package shows that it solved two blocks of equations numerically. In the background the package broke down the model into recursive blocks and solved them first symbolically and if not possible numerically.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The plots show the responses of the endogenous variables to a one standard deviation positive (indicated by Shock‚Å∫ in chart title) unanticipated shock. Therefore there are as many subplots as there are combinations of shocks and endogenous variables (which are impacted by the shock). Plots are composed of up to 9 subplots and the plot title shows the model name followed by the name of the shock and which plot we are seeing out of the plots for this shock (e.g. (1/3) means we see the first out of three plots for this shock). Subplots show the sorted endogenous variables with the left y-axis showing the level of the respective variable and the right y-axis showing the percent deviation from the SS (if variable is strictly positive). The horizontal black line marks the SS.","category":"page"},{"location":"tutorials/sw03/#Explore-other-parameter-values","page":"Smets and Wouters (2003)","title":"Explore other parameter values","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Playing around with the model is especially insightful in the early phase of model development. The package facilitates this process to the extent possible. Typically one wants to try different parameter values and see how the IRFs change. This can be done by using the parameters argument of the plot_irf function. We pass a Pair with the Symbol of the parameter (: in front of the parameter name) we want to change and its new value to the parameter argument (e.g. :alpha => 0.305). Furthermore, we don't want to see so many plot windows so we select the shocks and variables we want to see. Let's plot only the eta_R shocks by passing it as a Symbol to the shocks argument of the plot_irf function. For the variables we want to plot: U, Y, I, R, and C and achieve that by passing the a Vector of Symbols to the variables argument of the plot_irf function:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"plot_irf(SW03, \n         parameters = :alpha => 0.305, \n         variables = [:U,:Y,:I,:R,:C], \n         shocks = :eta_R)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"(Image: )","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"First, the package tells us which parameters changed and that this also changed the steady state. The new SS and model solution are permanently saved in the model object. Second, note that with the parameters the IRFs changed (e.g. compare the y-axis values for U). What happened in the background is that the package recalculated the SS and solved the model around the new SS. Updating the plot for new parameters is significantly faster than calling it the first time. This is because the first call triggers compilations of the model functions, and once compiled the user benefits from the performance of the specialised compiled code. Furthermore, finding the SS from a valid SS as a starting point is faster.","category":"page"},{"location":"tutorials/sw03/#Plot-model-simulation","page":"Smets and Wouters (2003)","title":"Plot model simulation","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Another insightful output is simulations of the model. Here we can use the plot_simulations function. Again we want to only look at a subset of the variables and specify it in the variables argument. To the same effect we can use the plot_irf function and specify in the shocks argument that we want to :simulate the model and set the periods argument to 100.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"plot_simulations(SW03, variables = [:U,:Y,:I,:R,:C])","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"(Image: Simulate RBC)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The plots show the models endogenous variables in response to random draws for all exogenous shocks over 100 periods.","category":"page"},{"location":"tutorials/sw03/#Steady-state-and-model-implied-standard-deviations","page":"Smets and Wouters (2003)","title":"Steady state and model implied standard deviations","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The package solves for the SS automatically and we got an idea of the SS values in the plots. If we want to see the SS values and the derivatives of the SS with respect to the model parameters we can call get_steady_state. The model has 39 parameters and 54 variables. Since we are not interested in all derivatives for all parameters we select a subset. This can be done by passing on a Vector of Symbols of the parameters to the parameter_derivatives argument:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"get_steady_state(SW03, parameter_derivatives = [:alpha,:beta])","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The first column of the returned matrix shows the SS while the second to last columns show the derivatives of the SS values (indicated in the rows) with respect to the parameters (indicated in the columns). For example, the derivative of C with respect to beta is 14.4994. This means that if we increase beta by 1, C would increase by 14.4994 approximately. Let's see how this plays out by changing beta from 0.99 to 0.991 (a change of +0.001):","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"get_steady_state(SW03, \n                 parameter_derivatives = [:alpha,:G_bar], \n                 parameters = :beta => .991)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Note that get_steady_state like all other get functions has the parameters argument. Hence, whatever output we are looking at we can change the parameters of the model. ","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The new value of beta changed the SS as expected and C increased by 0.01465. The elasticity (0.01465/0.001) comes close to the partial derivative previously calculated. The derivatives help understanding the effect of parameter changes on the steady state and make for easier navigation of the parameter space.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Next to the SS we can also show the model implied standard deviations of the model. get_moments takes care of this. Additionally we will set the parameter values to what they were in the beginning by passing on a Tuple of Pairs containing the Symbols of the parameters to be changed and their new (initial) values (e.g. (:alpha => 0.3, :beta => .99)).","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"moments = get_moments(SW03, \n                      parameter_derivatives = [:alpha,:beta], \n                      parameters = (:alpha => 0.3, :beta => .99));\nmoments[1]\nmoments[2]","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The first element returned by get_moments is the SS and identical to what we would get by calling get_steady_state. The second element contains the model implied standard deviations of the model variables and their derivatives with respect to the model parameters. For example, the derivative of the standard deviation of q with resect to alpha is -19.0184. In other words, the standard deviation of q decreases with increasing alpha.","category":"page"},{"location":"tutorials/sw03/#Model-solution-(policy-and-transition-function)","page":"Smets and Wouters (2003)","title":"Model solution (policy and transition function)","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"A further insightful output are the policy and transition functions of the the first order perturbation solution. To retrieve the solution we call the function get_solution:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"get_solution(SW03)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The solution provides information about how past states and present shocks impact present variables. The first row contains the SS for the variables denoted in the columns. The second to last rows contain the past states, with the time index ‚Çç‚Çã‚ÇÅ‚Çé, and present shocks, with exogenous variables denoted by ‚Çç‚Çì‚Çé. For example, the immediate impact of a shock to eta_w on z is 0.00222469. ","category":"page"},{"location":"tutorials/sw03/#Obtain-array-of-IRFs-or-model-simulations","page":"Smets and Wouters (2003)","title":"Obtain array of IRFs or model simulations","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Last but not least the user might want to obtain simulated time series of the model or IRFs without plotting them. For IRFs this is possible by calling get_irf:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"get_irf(SW03)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"which returns a 3-dimensional KeyedArray with variables in rows, the period in columns, and the shocks as the third dimension.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"For simulations this is possible by calling simulate:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"simulate(SW03)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"which returns the simulated data in a 3-dimensional KeyedArray of the same structure as for the IRFs.","category":"page"},{"location":"unfinished_docs/dsl/#DSL","page":"-","title":"DSL","text":"","category":"section"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"MacroModelling parses models written using a user-friendly syntax:","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"The most important rule is that variables are followed by the timing in squared brackets for endogenous variables, e.g. Y[0], exogenous variables are marked by certain keywords (see below), e.g. œµ[x], and parameters need no further syntax, e.g. Œ±.","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"A model written with this syntax allows the parser to identify, endogenous and exogenous variables and their timing as well as parameters.","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"Note that variables in the present (period t or 0) have to be denoted as such: [0]. The parser also takes care of creating auxilliary variables in case the model contains leads or lags of the variables larger than 1:","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"@model RBC_lead_lag begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * (eps_z[x-8] + eps_z[x-4] + eps_z[x+4] + eps_z_s[x])\n    cÃÑ‚Åª[0] = (c[0] + c[-1] + c[-2] + c[-3]) / 4\n    cÃÑ‚Å∫[0] = (c[0] + c[1] + c[2] + c[3]) / 4\nend","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"The parser recognises a variable as exogenous if the timing bracket contains one of the keyword/letters (case insensitive): x, ex, exo, exogenous. ","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"Valid declarations of exogenous variables: œµ[x], œµ[Exo], œµ[exOgenous]. ","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"Invalid declarations: œµ[xo], œµ[exogenously], œµ[main shock x]","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"Endogenous and exogenous variables can be in lead or lag, e.g.:  the following describe a lead of 1 period: Y[1], Y[+1], Y[+ 1], eps[x+1], eps[Exo + 1] and the same goes for lags and periods > 1: `k[-2], c[+12], eps[x-4]","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"Invalid declarations: Y[t-1], Y[t], Y[whatever], eps[x+t+1]","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"Equations must be within one line and the = sign is optional.","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"The parser recognises all functions in julia including those from StatsFuns.jl. Note that the syntax for distributions is the same as in MATLAB, e.g. normcdf. For those familiar with R the following also work: pnorm, dnorm, qnorm, and it also recognises: norminvcdf and norminv.","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"Given these rules it is straightforward to write down a model. Once declared using the @model <name of the model> macro, the package creates an object containing all necessary information regarding the equations of the model.","category":"page"},{"location":"unfinished_docs/dsl/#Lead-/-lags-and-auxilliary-variables","page":"-","title":"Lead / lags and auxilliary variables","text":"","category":"section"}]
}
