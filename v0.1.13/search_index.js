var documenterSearchIndex = {"docs":
[{"location":"unfinished_docs/how_to/#Use-calibration-equations","page":"-","title":"Use calibration equations","text":"","category":"section"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"Next we need to add the parameters of the model. The macro @parameters <name of the model> takes care of this:","category":"page"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend","category":"page"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"No need for line endings. If you want to define a parameter as a function of another parameter you can do this:","category":"page"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    beta1 = 1\n    beta2 = .95\n    Œ≤ | Œ≤ = beta2/beta1\nend","category":"page"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"Note that the parser takes parameters assigned to a numerical value first and then solves for the parameters defined by relationships: Œ≤ | .... This means also the following will work:","category":"page"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"@parameters RBC begin\n    Œ≤ | Œ≤ = beta2/beta1\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    beta1 = 1\n    beta2 = .95\nend","category":"page"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"More interestingly one can use (non-stochastic) steady state values in the relationships:","category":"page"},{"location":"unfinished_docs/how_to/","page":"-","title":"-","text":"@parameters RBC begin\n    Œ≤ = .95\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± | k[ss] / (4 * q[ss]) = 1.5\nend","category":"page"},{"location":"unfinished_docs/how_to/#Higher-order-perturbation-solutions","page":"-","title":"Higher order perturbation solutions","text":"","category":"section"},{"location":"unfinished_docs/how_to/#How-to-estimate-a-model","page":"-","title":"How to estimate a model","text":"","category":"section"},{"location":"unfinished_docs/how_to/#Interactive-plotting","page":"-","title":"Interactive plotting","text":"","category":"section"},{"location":"call_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"call_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MacroModelling]\nOrder   = [:function, :macro]","category":"page"},{"location":"api/#MacroModelling.autocorr","page":"API","title":"MacroModelling.autocorr","text":"See get_autocorrelation\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.corr","page":"API","title":"MacroModelling.corr","text":"See get_correlation\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.cov","page":"API","title":"MacroModelling.cov","text":"Wrapper for get_moments with covariance = true and non_stochastic_steady_state = false, variance = false, standard_deviation = false.\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.export_dynare","page":"API","title":"MacroModelling.export_dynare","text":"See write_mod_file\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.export_mod_file","page":"API","title":"MacroModelling.export_mod_file","text":"See write_mod_file\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.export_to_dynare","page":"API","title":"MacroModelling.export_to_dynare","text":"See write_mod_file\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.fevd","page":"API","title":"MacroModelling.fevd","text":"See get_conditional_variance_decomposition\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_IRF","page":"API","title":"MacroModelling.get_IRF","text":"See get_irf\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_SS","page":"API","title":"MacroModelling.get_SS","text":"See get_steady_state\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_SSS-Tuple","page":"API","title":"MacroModelling.get_SSS","text":"Wrapper for get_steady_state with stochastic = true.\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_autocorr","page":"API","title":"MacroModelling.get_autocorr","text":"See get_autocorrelation\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_autocorrelation-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.get_autocorrelation","text":"get_autocorrelation(ùìÇ; parameters, verbose)\n\n\nReturn the autocorrelations of endogenous variables using the linearised solution. \n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nparameters [Default: nothing]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter symbol and value. If the new parameter values differ from the previously defined the solution will be recalculated.\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nget_autocorrelation(RBC)\n# output\n2-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Variables ‚àà 4-element Vector{Symbol}\n‚Üí   Autocorrelation_orders ‚àà 5-element UnitRange{Int64}\nAnd data, 4√ó5 Matrix{Float64}:\n        (1)         (2)         (3)         (4)         (5)\n  (:c)    0.966974    0.927263    0.887643    0.849409    0.812761\n  (:k)    0.971015    0.931937    0.892277    0.853876    0.817041\n  (:q)    0.32237     0.181562    0.148347    0.136867    0.129944\n  (:z)    0.2         0.04        0.008       0.0016      0.00032\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_conditional_forecast-Tuple{MacroModelling.‚Ñ≥, Union{AxisKeys.KeyedArray{Union{Nothing, Float64}}, AxisKeys.KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}","page":"API","title":"MacroModelling.get_conditional_forecast","text":"get_conditional_forecast(\n    ùìÇ,\n    conditions;\n    shocks,\n    periods,\n    parameters,\n    variables,\n    conditions_in_levels,\n    levels,\n    verbose\n)\n\n\nReturn the conditional forecast given restrictions on endogenous variables and shocks (optional) in a 2-dimensional array. The algorithm finds the combinations of shocks with the smallest magnitude to match the conditions.\n\nLimited to the first order perturbation solution of the model.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\nconditions [Type: Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}}]: conditions for which to find the corresponding shocks. The input can have multiple formats, but for all types of entries the first dimension corresponds to the number of variables and the second dimension to the number of periods. The conditions can be specified using a matrix of type Matrix{Union{Nothing,Float64}}. In this case the conditions are matrix elements of type Float64 and all remaining (free) entries are nothing. You can also use a SparseMatrixCSC{Float64} as input. In this case only non-zero elements are taken as conditions. Note that you cannot condition variables to be zero using a SparseMatrixCSC{Float64} as input (use other input formats to do so). Another possibility to input conditions is by using a KeyedArray. You can use a KeyedArray{Union{Nothing,Float64}} where, similar to Matrix{Union{Nothing,Float64}}, all entries of type Float64 are recognised as conditions and all other entries have to be nothing. Furthermore, you can specify in the primary axis a subset of variables (of type Symbol) for which you specify conditions and all other variables are considered free. The same goes for the case when you use KeyedArray{Float64}} as input, whereas in this case the conditions for the specified variables bind for all periods specified in the KeyedArray, because there are no nothing entries permitted with this type.\n\nKeyword Arguments\n\nshocks [Default: nothing, Type: Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}, Nothing} = nothing]: known values of shocks. This entry allows the user to include certain shock values. By entering restrictions on the shock sin this way the problem to match the conditions on endogenous variables is restricted to the remaining free shocks in the repective period. The input can have multiple formats, but for all types of entries the first dimension corresponds to the number of shocks and the second dimension to the number of periods. The shocks can be specified using a matrix of type Matrix{Union{Nothing,Float64}}. In this case the shocks are matrix elements of type Float64 and all remaining (free) entries are nothing. You can also use a SparseMatrixCSC{Float64} as input. In this case only non-zero elements are taken as certain shock values. Note that you cannot condition shocks to be zero using a SparseMatrixCSC{Float64} as input (use other input formats to do so). Another possibility to input known shocks is by using a KeyedArray. You can use a KeyedArray{Union{Nothing,Float64}} where, similar to Matrix{Union{Nothing,Float64}}, all entries of type Float64 are recognised as known shocks and all other entries have to be nothing. Furthermore, you can specify in the primary axis a subset of shocks (of type Symbol) for which you specify values and all other shocks are considered free. The same goes for the case when you use KeyedArray{Float64}} as input, whereas in this case the values for the specified shocks bind for all periods specified in the KeyedArray, because there are no nothing entries permitted with this type.\nperiods [Default: 40, Type: Int]: the total number of periods is the sum of the argument provided here and the maximum of periods of the shocks or conditions argument.\nvariables [Default: :all]: variables for which to show the results. Inputs can be either a Symbol (e.g. :y or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol} or Vector{Symbol}. Any variables not part of the model will trigger a warning. :all will contain all variables but not the auxilliary ones. all_including_auxilliary also includes the auxilliary variables in the output.\n\nconditions_in_levels [Default: false, Type: Bool]: indicator whether the conditions are provided in levels. If true the input to the conditions argument will have the non stochastic steady state substracted.\n\nlevels [Default: false, Type: Bool]: return levels or absolute deviations from steady state.\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nExamples\n\nusing MacroModelling\nusing SparseArrays, AxisKeys\n\n@model RBC_CME begin\n    y[0]=A[0]*k[-1]^alpha\n    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))\n    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])\n    R[0] * beta =(Pi[0]/Pibar)^phi_pi\n    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]\n    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]\n    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]\nend\n\n\n@parameters RBC_CME begin\n    alpha = .157\n    beta = .999\n    delta = .0226\n    Pibar = 1.0008\n    phi_pi = 1.5\n    rhoz = .9\n    std_eps = .0068\n    rho_z_delta = .9\n    std_z_delta = .005\nend\n\n# c is conditioned to deviate by 0.01 in period 1 and y is conditioned to deviate by 0.02 in period 3\nconditions = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,2,2),Variables = [:c,:y], Periods = 1:2)\nconditions[1,1] = .01\nconditions[2,2] = .02\n\n# in period 2 second shock (eps_z) is conditioned to take a value of 0.05\nshocks = Matrix{Union{Nothing,Float64}}(undef,2,1)\nshocks[1,1] = .05\n\nget_conditional_forecast(RBC_CME, conditions, shocks = shocks)\n# output\n2-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Variables_and_shocks ‚àà 9-element Vector{Symbol}\n‚Üí   Periods ‚àà 42-element UnitRange{Int64}\nAnd data, 9√ó42 Matrix{Float64}:\n                (1)            (2)           ‚Ä¶  (41)            (42)\n  (:A)            0.0313639      0.0134792         0.000221372     0.000199235\n  (:Pi)           0.000780257    0.00020929       -0.000146071    -0.000140137\n  (:R)            0.00117156     0.00031425       -0.000219325    -0.000210417\n  (:c)            0.01           0.00600605        0.00213278      0.00203751\n  (:k)            0.034584       0.0477482   ‚Ä¶     0.0397631       0.0380482\n  (:y)            0.0446375      0.02              0.00129544      0.001222\n  (:z_delta)      0.00025        0.000225          3.69522e-6      3.3257e-6\n  (:delta_eps)    0.05           0.0               0.0             0.0\n  (:eps_z)        4.61234       -2.16887           0.0             0.0\n\n# The same can be achieved with the other input formats:\n# conditions = Matrix{Union{Nothing,Float64}}(undef,7,2)\n# conditions[4,1] = .01\n# conditions[6,2] = .02\n\n# using SparseArrays\n# conditions = spzeros(7,2)\n# conditions[4,1] = .01\n# conditions[6,2] = .02\n\n# shocks = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,1),Variables = [:delta_eps], Periods = [1])\n# shocks[1,1] = .05\n\n# using SparseArrays\n# shocks = spzeros(2,1)\n# shocks[1,1] = .05\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.get_conditional_variance_decomposition","text":"get_conditional_variance_decomposition(\n    ùìÇ;\n    periods,\n    parameters,\n    verbose\n)\n\n\nReturn the conditional variance decomposition of endogenous variables with regards to the shocks using the linearised solution. \n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nperiods [Default: [1:20...,Inf], Type: Union{Vector{Int},Vector{Float64},UnitRange{Int64}}]: vector of periods for which to calculate the conditional variance decomposition. If the vector conatins Inf, also the unconditional variance decomposition is calculated (same output as get_variance_decomposition).\nparameters [Default: nothing]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter symbol and value. If the new parameter values differ from the previously defined the solution will be recalculated.\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nExamples\n\nusing MacroModelling\n\n@model RBC_CME begin\n    y[0]=A[0]*k[-1]^alpha\n    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))\n    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])\n    R[0] * beta =(Pi[0]/Pibar)^phi_pi\n    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]\n    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]\n    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]\nend\n\n\n@parameters RBC_CME begin\n    alpha = .157\n    beta = .999\n    delta = .0226\n    Pibar = 1.0008\n    phi_pi = 1.5\n    rhoz = .9\n    std_eps = .0068\n    rho_z_delta = .9\n    std_z_delta = .005\nend\n\nget_conditional_variance_decomposition(RBC_CME)\n# output\n3-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Variables ‚àà 7-element Vector{Symbol}\n‚Üí   Shocks ‚àà 2-element Vector{Symbol}\n‚ó™   Periods ‚àà 21-element Vector{Float64}\nAnd data, 7√ó2√ó21 Array{Float64, 3}:\n[showing 3 of 21 slices]\n[:, :, 1] ~ (:, :, 1.0):\n              (:delta_eps)  (:eps_z)\n  (:A)         0.0           1.0\n  (:Pi)        0.00158668    0.998413\n  (:R)         0.00158668    0.998413\n  (:c)         0.0277348     0.972265\n  (:k)         0.00869568    0.991304\n  (:y)         0.0           1.0\n  (:z_delta)   1.0           0.0\n\n[:, :, 11] ~ (:, :, 11.0):\n              (:delta_eps)  (:eps_z)\n  (:A)         1.29651e-31   1.0\n  (:Pi)        0.0245641     0.975436\n  (:R)         0.0245641     0.975436\n  (:c)         0.0175249     0.982475\n  (:k)         0.00869568    0.991304\n  (:y)         7.63511e-5    0.999924\n  (:z_delta)   1.0           0.0\n\n[:, :, 21] ~ (:, :, Inf):\n              (:delta_eps)  (:eps_z)\n  (:A)         2.47454e-30   1.0\n  (:Pi)        0.0156771     0.984323\n  (:R)         0.0156771     0.984323\n  (:c)         0.0134672     0.986533\n  (:k)         0.00869568    0.991304\n  (:y)         0.000313462   0.999687\n  (:z_delta)   1.0           0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_corr","page":"API","title":"MacroModelling.get_corr","text":"See get_correlation\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_correlation-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.get_correlation","text":"get_correlation(ùìÇ; parameters, verbose)\n\n\nReturn the correlations of endogenous variables using the linearised solution. \n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nparameters [Default: nothing]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter symbol and value. If the new parameter values differ from the previously defined the solution will be recalculated.\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nget_correlation(RBC)\n# output\n2-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Variables ‚àà 4-element Vector{Symbol}\n‚Üí   ùëâùëéùëüùëñùëéùëèùëôùëíùë† ‚àà 4-element Vector{Symbol}\nAnd data, 4√ó4 Matrix{Float64}:\n        (:c)       (:k)       (:q)       (:z)\n  (:c)   1.0        0.999812   0.550168   0.314562\n  (:k)   0.999812   1.0        0.533879   0.296104\n  (:q)   0.550168   0.533879   1.0        0.965726\n  (:z)   0.314562   0.296104   0.965726   1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_cov","page":"API","title":"MacroModelling.get_cov","text":"Wrapper for get_moments with covariance = true and non_stochastic_steady_state = false, variance = false, standard_deviation = false.\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_covariance-Tuple","page":"API","title":"MacroModelling.get_covariance","text":"Wrapper for get_moments with covariance = true and non_stochastic_steady_state = false, variance = false, standard_deviation = false.\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_fevd","page":"API","title":"MacroModelling.get_fevd","text":"See get_conditional_variance_decomposition\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_first_order_solution","page":"API","title":"MacroModelling.get_first_order_solution","text":"See get_solution\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_forecast_error_variance_decomposition","page":"API","title":"MacroModelling.get_forecast_error_variance_decomposition","text":"See get_conditional_variance_decomposition\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥, Vector}","page":"API","title":"MacroModelling.get_irf","text":"get_irf(\n    ùìÇ,\n    parameters;\n    periods,\n    variables,\n    shocks,\n    negative_shock,\n    initial_state,\n    levels,\n    verbose\n)\n\n\nReturn impulse response functions (IRFs) of the model in a 3-dimensional array. Function to use when differentiating IRFs with repect to parameters.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\nparameters [Type: Vector]: Parameter values in alphabetical order (sorted by parameter name).\n\nKeyword Arguments\n\nperiods [Default: 40, Type: Int]: number of periods for which to calculate the IRFs. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the simulation continues.\nvariables [Default: :all]: variables for which to show the results. Inputs can be either a Symbol (e.g. :y or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol} or Vector{Symbol}. Any variables not part of the model will trigger a warning. :all will contain all variables but not the auxilliary ones. all_including_auxilliary also includes the auxilliary variables in the output.\nshocks [Default: :all]: shocks for which to calculate the IRFs. Inputs can be either a Symbol (e.g. :y, :simulate, :none, or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol}, Vector{Symbol}, Matrix{Float64}, or KeyedArray{Float64}. :simulate triggers random draws of all shocks. A series of shocks can be passed on using either a Matrix{Float64}, or a KeyedArray{Float64} as input with shocks in rows and periods in columns. The period of the simulation will correspond to the length of the input in the period dimension + the number of periods defined in periods. If the series of shocks is input as a KeyedArray{Float64} make sure to name the rows with valid shock names of type Symbol. Any shocks not part of the model will trigger a warning. :none in combination with an initial_state can be used for deterministic simulations.\nnegative_shock [Default: false, Type: Bool]: calculate a negative shock. Relevant for generalised IRFs.\ngeneralised_irf [Default: false, Type: Bool]: calculate generalised IRFs. Relevant for nonlinear solutions. Reference steady state for deviations is the stochastic steady state.\ninitial_state [Default: [0.0], Type: Vector{Float64}]: provide state (in levels, not deviations) from which to start IRFs. Relevant for normal IRFs. The state includes all variables as well as exogenous variables in leads or lags if present.\nlevels [Default: false, Type: Bool]: return levels or absolute deviations from steady state.\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nget_irf(RBC, RBC.parameter_values)\n# output\n4√ó40√ó1 Array{Float64, 3}:\n[:, :, 1] =\n 0.00674687  0.00729773  0.00715114  0.00687615  ‚Ä¶  0.00146962   0.00140619\n 0.0620937   0.0718322   0.0712153   0.0686381      0.0146789    0.0140453\n 0.0688406   0.0182781   0.00797091  0.0057232      0.00111425   0.00106615\n 0.01        0.002       0.0004      8.0e-5         2.74878e-29  5.49756e-30\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_irf-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.get_irf","text":"get_irf(\n    ùìÇ;\n    periods,\n    algorithm,\n    parameters,\n    variables,\n    shocks,\n    negative_shock,\n    generalised_irf,\n    initial_state,\n    levels,\n    verbose\n)\n\n\nReturn impulse response functions (IRFs) of the model in a 3-dimensional KeyedArray\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nperiods [Default: 40, Type: Int]: number of periods for which to calculate the IRFs. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the simulation continues.\nalgorithm [Default: :first_order, Type: Symbol]: algorithm to solve for the dynamics of the model.\nparameters [Default: nothing]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter symbol and value. If the new parameter values differ from the previously defined the solution will be recalculated.\nvariables [Default: :all]: variables for which to show the results. Inputs can be either a Symbol (e.g. :y or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol} or Vector{Symbol}. Any variables not part of the model will trigger a warning. :all will contain all variables but not the auxilliary ones. all_including_auxilliary also includes the auxilliary variables in the output.\nshocks [Default: :all]: shocks for which to calculate the IRFs. Inputs can be either a Symbol (e.g. :y, :simulate, :none, or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol}, Vector{Symbol}, Matrix{Float64}, or KeyedArray{Float64}. :simulate triggers random draws of all shocks. A series of shocks can be passed on using either a Matrix{Float64}, or a KeyedArray{Float64} as input with shocks in rows and periods in columns. The period of the simulation will correspond to the length of the input in the period dimension + the number of periods defined in periods. If the series of shocks is input as a KeyedArray{Float64} make sure to name the rows with valid shock names of type Symbol. Any shocks not part of the model will trigger a warning. :none in combination with an initial_state can be used for deterministic simulations.\nnegative_shock [Default: false, Type: Bool]: calculate a negative shock. Relevant for generalised IRFs.\ngeneralised_irf [Default: false, Type: Bool]: calculate generalised IRFs. Relevant for nonlinear solutions. Reference steady state for deviations is the stochastic steady state.\ninitial_state [Default: [0.0], Type: Vector{Float64}]: provide state (in levels, not deviations) from which to start IRFs. Relevant for normal IRFs. The state includes all variables as well as exogenous variables in leads or lags if present.\nlevels [Default: false, Type: Bool]: return levels or absolute deviations from steady state.\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nget_irf(RBC)\n# output\n3-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Variables ‚àà 4-element Vector{Symbol}\n‚Üí   Periods ‚àà 40-element UnitRange{Int64}\n‚ó™   Shocks ‚àà 1-element Vector{Symbol}\nAnd data, 4√ó40√ó1 Array{Float64, 3}:\n[:, :, 1] ~ (:, :, :eps_z):\n        (1)           (2)           ‚Ä¶  (39)            (40)\n  (:c)    0.00674687    0.00729773        0.00146962      0.00140619\n  (:k)    0.0620937     0.0718322         0.0146789       0.0140453\n  (:q)    0.0688406     0.0182781         0.00111425      0.00106615\n  (:z)    0.01          0.002             2.74878e-29     5.49756e-30\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_irfs","page":"API","title":"MacroModelling.get_irfs","text":"See get_irf\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥, Vector}","page":"API","title":"MacroModelling.get_moments","text":"get_moments(\n    ùìÇ,\n    parameters;\n    non_stochastic_steady_state,\n    standard_deviation,\n    variance,\n    covariance,\n    verbose\n)\n\n\nReturn the first and second moments of endogenous variables using the linearised solution. By default returns: non stochastic steady state (SS), and standard deviations, but can also return variances, and covariance matrix. Function to use when differentiating model moments with repect to parameters.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\nparameters [Type: Vector]: Parameter values in alphabetical order (sorted by parameter name).\n\nKeyword Arguments\n\nnon_stochastic_steady_state [Default: true, Type: Bool]: switch to return SS of endogenous variables\nstandard_deviation [Default: true, Type: Bool]: switch to return standard deviation of endogenous variables\nvariance [Default: false, Type: Bool]: switch to return variance of endogenous variables\ncovariance [Default: false, Type: Bool]: switch to return covariance matrix of endogenous variables\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nget_moments(RBC, RBC.parameter_values)\n# output\n2-element Vector{Any}:\n [5.936252888048724, 47.39025414828808, 6.884057971014486, 0.0]\n [0.026664203785255254, 0.26467737291222343, 0.07393254045396497, 0.010206207261596576]\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_moments-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.get_moments","text":"get_moments(\n    ùìÇ;\n    parameters,\n    non_stochastic_steady_state,\n    standard_deviation,\n    variance,\n    covariance,\n    derivatives,\n    parameter_derivatives,\n    verbose\n)\n\n\nReturn the first and second moments of endogenous variables using the linearised solution. By default returns: non stochastic steady state (SS), and standard deviations, but can also return variances, and covariance matrix.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nparameters [Default: nothing]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter symbol and value. If the new parameter values differ from the previously defined the solution will be recalculated.\nnon_stochastic_steady_state [Default: true, Type: Bool]: switch to return SS of endogenous variables\nstandard_deviation [Default: true, Type: Bool]: switch to return standard deviation of endogenous variables\nvariance [Default: false, Type: Bool]: switch to return variance of endogenous variables\ncovariance [Default: false, Type: Bool]: switch to return covariance matrix of endogenous variables\nderivatives [Default: true, Type: Bool]: calculate derivatives with respect to the parameters.\nparameter_derivatives [Default: :all]: parameters for which to calculate partial derivatives. Inputs can be either a Symbol (e.g. :alpha, or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol} or Vector{Symbol}.\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nmoments = get_moments(RBC);\n\nmoments[1]\n# output\n2-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Variables ‚àà 4-element Vector{Symbol}\n‚Üí   Steady_state_and_‚àÇsteady_state‚àÇparameter ‚àà 6-element Vector{Symbol}\nAnd data, 4√ó6 Matrix{Float64}:\n        (:Steady_state)  (:std_z)  (:œÅ)     (:Œ¥)      (:Œ±)       (:Œ≤)\n  (:c)   5.93625          0.0       0.0   -116.072    55.786     76.1014\n  (:k)  47.3903           0.0       0.0  -1304.95    555.264   1445.93\n  (:q)   6.88406          0.0       0.0    -94.7805   66.8912   105.02\n  (:z)   0.0              0.0       0.0      0.0       0.0        0.0\n\nmoments[2]\n# output\n2-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Variables ‚àà 4-element Vector{Symbol}\n‚Üí   Standard_deviation_and_‚àÇstandard_deviation‚àÇparameter ‚àà 6-element Vector{Symbol}\nAnd data, 4√ó6 Matrix{Float64}:\n        (:Standard_deviation)  (:std_z)  ‚Ä¶  (:Œ¥)       (:Œ±)       (:Œ≤)\n  (:c)   0.0266642              2.66642     -0.384359   0.2626     0.144789\n  (:k)   0.264677              26.4677      -5.74194    2.99332    6.30323\n  (:q)   0.0739325              7.39325     -0.974722   0.726551   1.08\n  (:z)   0.0102062              1.02062      0.0        0.0        0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_non_stochastic_steady_state-Tuple","page":"API","title":"MacroModelling.get_non_stochastic_steady_state","text":"Wrapper for get_steady_state with stochastic = false.\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_perturbation_solution","page":"API","title":"MacroModelling.get_perturbation_solution","text":"See get_solution\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_solution-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.get_solution","text":"get_solution(ùìÇ; parameters, algorithm, verbose)\n\n\nReturn the linearised solution and the non stochastic steady state (SS) of the model.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nparameters [Default: nothing]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter symbol and value. If the new parameter values differ from the previously defined the solution will be recalculated.\nalgorithm [Default: :first_order, Type: Symbol]: algorithm to solve for the dynamics of the model. Only linear algorithms allowed.\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nThe returned KeyedArray shows the SS, policy and transition functions of the model. The columns show the varibales including auxilliary endogenous and exogenous variables (due to leads and lags > 1). The rows are the SS, followed by the states, and exogenous shocks.  Subscripts following variable names indicate the timing (e.g. variable‚Çç‚Çã‚ÇÅ‚Çé  indicates the variable being in the past). Superscripts indicate leads or lags (e.g. variable·¥∏‚ÅΩ¬≤‚Åæ indicates the variable being in lead by two periods). If no super- or subscripts follow the variable name, the variable is in the present.\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nget_solution(RBC)\n# output\n2-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Steady_state__States__Shocks ‚àà 4-element Vector{Symbol}\n‚Üí   Variables ‚àà 4-element Vector{Symbol}\nAnd data, 4√ó4 adjoint(::Matrix{Float64}) with eltype Float64:\n                   (:c)         (:k)        (:q)        (:z)\n  (:Steady_state)   5.93625     47.3903      6.88406     0.0\n  (:k‚Çç‚Çã‚ÇÅ‚Çé)          0.0957964    0.956835    0.0726316  -0.0\n  (:z‚Çç‚Çã‚ÇÅ‚Çé)          0.134937     1.24187     1.37681     0.2\n  (:eps_z‚Çç‚Çì‚Çé)       0.00674687   0.0620937   0.0688406   0.01\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_ss","page":"API","title":"MacroModelling.get_ss","text":"See get_steady_state\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_standard_deviation-Tuple","page":"API","title":"MacroModelling.get_standard_deviation","text":"Wrapper for get_moments with standard_deviation = true and non_stochastic_steady_state = false, variance = false, covariance = false.\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_std","page":"API","title":"MacroModelling.get_std","text":"Wrapper for get_moments with standard_deviation = true and non_stochastic_steady_state = false, variance = false, covariance = false.\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_steady_state-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.get_steady_state","text":"get_steady_state(\n    ùìÇ;\n    parameters,\n    derivatives,\n    stochastic,\n    algorithm,\n    parameter_derivatives,\n    verbose\n)\n\n\nReturn the (non stochastic) steady state and derivatives with respect to model parameters.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nparameters [Default: nothing]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter symbol and value. If the new parameter values differ from the previously defined the solution will be recalculated.\nderivatives [Default: true, Type: Bool]: calculate derivatives with respect to the parameters.\nstochastic [Default: false, Type: Bool]: return stochastic steady state using second order perturbation. No derivatives are calculated.\nalgorithm [Default: :first_order, Type: Symbol]: algorithm to solve for the dynamics of the model.\nparameter_derivatives [Default: :all]: parameters for which to calculate partial derivatives. Inputs can be either a Symbol (e.g. :alpha, or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol} or Vector{Symbol}.\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nThe columns show the SS and parameters for which derivatives are taken. The rows show the variables.\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nget_steady_state(RBC)\n# output\n2-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Variables_and_calibrated_parameters ‚àà 4-element Vector{Symbol}\n‚Üí   Steady_state_and_‚àÇsteady_state‚àÇparameter ‚àà 6-element Vector{Symbol}\nAnd data, 4√ó6 Matrix{Float64}:\n        (:Steady_state)  (:std_z)  (:œÅ)     (:Œ¥)      (:Œ±)       (:Œ≤)\n  (:c)   5.93625          0.0       0.0   -116.072    55.786     76.1014\n  (:k)  47.3903           0.0       0.0  -1304.95    555.264   1445.93\n  (:q)   6.88406          0.0       0.0    -94.7805   66.8912   105.02\n  (:z)   0.0              0.0       0.0      0.0       0.0        0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_stochastic_steady_state-Tuple","page":"API","title":"MacroModelling.get_stochastic_steady_state","text":"Wrapper for get_steady_state with stochastic = true.\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_var","page":"API","title":"MacroModelling.get_var","text":"Wrapper for get_moments with variance = true and non_stochastic_steady_state = false, standard_deviation = false, covariance = false.\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_var_decomp","page":"API","title":"MacroModelling.get_var_decomp","text":"See get_variance_decomposition\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.get_variance-Tuple","page":"API","title":"MacroModelling.get_variance","text":"Wrapper for get_moments with variance = true and non_stochastic_steady_state = false, standard_deviation = false, covariance = false.\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.get_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.get_variance_decomposition","text":"get_variance_decomposition(ùìÇ; parameters, verbose)\n\n\nReturn the variance decomposition of endogenous variables with regards to the shocks using the linearised solution. \n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nparameters [Default: nothing]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter symbol and value. If the new parameter values differ from the previously defined the solution will be recalculated.\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nExamples\n\nusing MacroModelling\n\n@model RBC_CME begin\n    y[0]=A[0]*k[-1]^alpha\n    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))\n    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])\n    R[0] * beta =(Pi[0]/Pibar)^phi_pi\n    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]\n    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]\n    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]\nend\n\n\n@parameters RBC_CME begin\n    alpha = .157\n    beta = .999\n    delta = .0226\n    Pibar = 1.0008\n    phi_pi = 1.5\n    rhoz = .9\n    std_eps = .0068\n    rho_z_delta = .9\n    std_z_delta = .005\nend\n\nget_variance_decomposition(RBC_CME)\n# output\n2-dimensional KeyedArray(NamedDimsArray(...)) with keys:\n‚Üì   Variables ‚àà 7-element Vector{Symbol}\n‚Üí   Shocks ‚àà 2-element Vector{Symbol}\nAnd data, 7√ó2 Matrix{Float64}:\n              (:delta_eps)  (:eps_z)\n  (:A)         1.69478e-29   1.0\n  (:Pi)        0.0156771     0.984323\n  (:R)         0.0156771     0.984323\n  (:c)         0.0134672     0.986533\n  (:k)         0.00869568    0.991304\n  (:y)         0.000313462   0.999687\n  (:z_delta)   1.0           0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.gr_backend","page":"API","title":"MacroModelling.gr_backend","text":"gr_backend()\n\nRenaming and reexport of Plot.jl function gr() to define GR.jl as backend\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.import_dynare","page":"API","title":"MacroModelling.import_dynare","text":"See translate_mod_file\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.import_model","page":"API","title":"MacroModelling.import_model","text":"See translate_mod_file\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.plot_IRF","page":"API","title":"MacroModelling.plot_IRF","text":"See plot_irf\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.plot_conditional_forecast-Tuple{MacroModelling.‚Ñ≥, Union{AxisKeys.KeyedArray{Union{Nothing, Float64}}, AxisKeys.KeyedArray{Float64}, SparseArrays.SparseMatrixCSC{Float64}, Matrix{Union{Nothing, Float64}}}}","page":"API","title":"MacroModelling.plot_conditional_forecast","text":"plot_conditional_forecast(\n    ùìÇ,\n    conditions;\n    shocks,\n    periods,\n    parameters,\n    variables,\n    conditions_in_levels,\n    levels,\n    show_plots,\n    save_plots,\n    save_plots_format,\n    save_plots_path,\n    plots_per_page,\n    verbose\n)\n\n\nPlot conditional forecast given restrictions on endogenous variables and shocks (optional) of the model. The algorithm finds the combinations of shocks with the smallest magnitude to match the conditions and plots both the endogenous variables and shocks.\n\nThe left axis shows the level, and the right axis the deviation from the non stochastic steady state. Variable names are above the subplots, conditioned values are marked, and the title provides information about the model, and number of pages.\n\nLimited to the first order perturbation solution of the model.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\nconditions [Type: Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}}]: conditions for which to find the corresponding shocks. The input can have multiple formats, but for all types of entries the first dimension corresponds to the number of variables and the second dimension to the number of periods. The conditions can be specified using a matrix of type Matrix{Union{Nothing,Float64}}. In this case the conditions are matrix elements of type Float64 and all remaining (free) entries are nothing. You can also use a SparseMatrixCSC{Float64} as input. In this case only non-zero elements are taken as conditions. Note that you cannot condition variables to be zero using a SparseMatrixCSC{Float64} as input (use other input formats to do so). Another possibility to input conditions is by using a KeyedArray. You can use a KeyedArray{Union{Nothing,Float64}} where, similar to Matrix{Union{Nothing,Float64}}, all entries of type Float64 are recognised as conditions and all other entries have to be nothing. Furthermore, you can specify in the primary axis a subset of variables (of type Symbol) for which you specify conditions and all other variables are considered free. The same goes for the case when you use KeyedArray{Float64}} as input, whereas in this case the conditions for the specified variables bind for all periods specified in the KeyedArray, because there are no nothing entries permitted with this type.\n\nKeyword Arguments\n\nshocks [Default: nothing, Type: Union{Matrix{Union{Nothing,Float64}}, SparseMatrixCSC{Float64}, KeyedArray{Union{Nothing,Float64}}, KeyedArray{Float64}, Nothing} = nothing]: known values of shocks. This entry allows the user to include certain shock values. By entering restrictions on the shock sin this way the problem to match the conditions on endogenous variables is restricted to the remaining free shocks in the repective period. The input can have multiple formats, but for all types of entries the first dimension corresponds to the number of shocks and the second dimension to the number of periods. The shocks can be specified using a matrix of type Matrix{Union{Nothing,Float64}}. In this case the shocks are matrix elements of type Float64 and all remaining (free) entries are nothing. You can also use a SparseMatrixCSC{Float64} as input. In this case only non-zero elements are taken as certain shock values. Note that you cannot condition shocks to be zero using a SparseMatrixCSC{Float64} as input (use other input formats to do so). Another possibility to input known shocks is by using a KeyedArray. You can use a KeyedArray{Union{Nothing,Float64}} where, similar to Matrix{Union{Nothing,Float64}}, all entries of type Float64 are recognised as known shocks and all other entries have to be nothing. Furthermore, you can specify in the primary axis a subset of shocks (of type Symbol) for which you specify values and all other shocks are considered free. The same goes for the case when you use KeyedArray{Float64}} as input, whereas in this case the values for the specified shocks bind for all periods specified in the KeyedArray, because there are no nothing entries permitted with this type.\nperiods [Default: 40, Type: Int]: the total number of periods is the sum of the argument provided here and the maximum of periods of the shocks or conditions argument.\nvariables [Default: :all]: variables for which to show the results. Inputs can be either a Symbol (e.g. :y or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol} or Vector{Symbol}. Any variables not part of the model will trigger a warning. :all will contain all variables but not the auxilliary ones. all_including_auxilliary also includes the auxilliary variables in the output.\n\nconditions_in_levels [Default: false, Type: Bool]: indicator whether the conditions are provided in levels. If true the input to the conditions argument will have the non stochastic steady state substracted.\n\nlevels [Default: false, Type: Bool]: return levels or absolute deviations from steady state.\nshow_plots [Default: true, Type: Bool]: show plots. Separate plots per shocks and varibles depending on number of variables and plots_per_page.\nsave_plots [Default: false, Type: Bool]: switch to save plots using path and extension from save_plots_path and save_plots_format. Separate files per shocks and variables depending on number of variables and plots_per_page\nsave_plots_path [Default: pwd(), Type: String]: path where to save plots\nsave_plots_format [Default: :pdf, Type: Symbol]: output format of saved plots. See input formats compatible with GR for valid formats.\nplots_per_page [Default: 9, Type: Int]: how many plots to show per page\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nExamples\n\nusing MacroModelling\nusing SparseArrays\n\n@model RBC_CME begin\n    y[0]=A[0]*k[-1]^alpha\n    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))\n    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])\n    R[0] * beta =(Pi[0]/Pibar)^phi_pi\n    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]\n    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]\n    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]\nend\n\n@parameters RBC_CME begin\n    alpha = .157\n    beta = .999\n    delta = .0226\n    Pibar = 1.0008\n    phi_pi = 1.5\n    rhoz = .9\n    std_eps = .0068\n    rho_z_delta = .9\n    std_z_delta = .005\nend\n\n# c is conditioned to deviate by 0.01 in period 1 and y is conditioned to deviate by 0.02 in period 3\nconditions = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,2,2),Variables = [:c,:y], Periods = 1:2)\nconditions[1,1] = .01\nconditions[2,2] = .02\n\n# in period 2 second shock (eps_z) is conditioned to take a value of 0.05\nshocks = Matrix{Union{Nothing,Float64}}(undef,2,1)\nshocks[1,1] = .05\n\nplot_conditional_forecast(RBC_CME, conditions, shocks = shocks)\n\n# The same can be achieved with the other input formats:\n# conditions = Matrix{Union{Nothing,Float64}}(undef,7,2)\n# conditions[4,1] = .01\n# conditions[6,2] = .02\n\n# using SparseArrays\n# conditions = spzeros(7,2)\n# conditions[4,1] = .01\n# conditions[6,2] = .02\n\n# shocks = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,1),Variables = [:delta_eps], Periods = [1])\n# shocks[1,1] = .05\n\n# using SparseArrays\n# shocks = spzeros(2,1)\n# shocks[1,1] = .05\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.plot_conditional_variance_decomposition-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.plot_conditional_variance_decomposition","text":"plot_conditional_variance_decomposition(\n    ùìÇ;\n    periods,\n    variables,\n    parameters,\n    show_plots,\n    save_plots,\n    save_plots_format,\n    save_plots_path,\n    plots_per_page,\n    verbose\n)\n\n\nPlot conditional variance decomposition of the model.\n\nThe vertical axis shows the share of the shocks variance contribution, and horizontal axis the period of the variance decomposition. The stacked bars represent each shocks variance contribution at a specific time horizon.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nperiods [Default: 40, Type: Int]: number of periods for which to calculate the IRFs. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the simulation continues.\nvariables [Default: :all]: variables for which to show the results. Inputs can be either a Symbol (e.g. :y or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol} or Vector{Symbol}. Any variables not part of the model will trigger a warning. :all will contain all variables but not the auxilliary ones. all_including_auxilliary also includes the auxilliary variables in the output.\nparameters [Default: nothing]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter symbol and value. If the new parameter values differ from the previously defined the solution will be recalculated.\nshow_plots [Default: true, Type: Bool]: show plots. Separate plots per shocks and varibles depending on number of variables and plots_per_page.\nsave_plots [Default: false, Type: Bool]: switch to save plots using path and extension from save_plots_path and save_plots_format. Separate files per shocks and variables depending on number of variables and plots_per_page\nsave_plots_path [Default: pwd(), Type: String]: path where to save plots\nsave_plots_format [Default: :pdf, Type: Symbol]: output format of saved plots. See input formats compatible with GR for valid formats.\nplots_per_page [Default: 9, Type: Int]: how many plots to show per page\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nExamples\n\nusing MacroModelling\n\n@model RBC_CME begin\n    y[0]=A[0]*k[-1]^alpha\n    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))\n    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])\n    R[0] * beta =(Pi[0]/Pibar)^phi_pi\n    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]\n    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]\n    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]\nend\n\n@parameters RBC_CME begin\n    alpha = .157\n    beta = .999\n    delta = .0226\n    Pibar = 1.0008\n    phi_pi = 1.5\n    rhoz = .9\n    std_eps = .0068\n    rho_z_delta = .9\n    std_z_delta = .005\nend\n\nplot_conditional_variance_decomposition(RBC_CME)\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.plot_fevd","page":"API","title":"MacroModelling.plot_fevd","text":"See plot_conditional_variance_decomposition\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.plot_forecast_error_variance_decomposition","page":"API","title":"MacroModelling.plot_forecast_error_variance_decomposition","text":"See plot_conditional_variance_decomposition\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.plot_irf-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.plot_irf","text":"plot_irf(\n    ùìÇ;\n    periods,\n    shocks,\n    variables,\n    parameters,\n    show_plots,\n    save_plots,\n    save_plots_format,\n    save_plots_path,\n    plots_per_page,\n    algorithm,\n    negative_shock,\n    generalised_irf,\n    initial_state,\n    verbose\n)\n\n\nPlot impulse response functions (IRFs) of the model.\n\nThe left axis shows the level, and the right the deviation from the reference steady state. Linear solutions have the non stochastic steady state as reference other solution the stochastic steady state. The horizontal black line indicates the reference steady state. Variable names are above the subplots and the title provides information about the model, shocks and number of pages per shock.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\nKeyword Arguments\n\nplots_per_page [Default: 9, Type: Int]: how many plots to show per page\nsave_plots [Default: false, Type: Bool]: switch to save plots using path and extension from save_plots_path and save_plots_format. Separate files per shocks and variables depending on number of variables and plots_per_page\nsave_plots_path [Default: pwd(), Type: String]: path where to save plots\nsave_plots_format [Default: :pdf, Type: Symbol]: output format of saved plots. See input formats compatible with GR for valid formats.\nshow_plots [Default: true, Type: Bool]: show plots. Separate plots per shocks and varibles depending on number of variables and plots_per_page.\nperiods [Default: 40, Type: Int]: number of periods for which to calculate the IRFs. In case a matrix of shocks was provided, periods defines how many periods after the series of shocks the simulation continues.\nalgorithm [Default: :first_order, Type: Symbol]: algorithm to solve for the dynamics of the model.\nparameters [Default: nothing]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter symbol and value. If the new parameter values differ from the previously defined the solution will be recalculated.\nvariables [Default: :all]: variables for which to show the results. Inputs can be either a Symbol (e.g. :y or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol} or Vector{Symbol}. Any variables not part of the model will trigger a warning. :all will contain all variables but not the auxilliary ones. all_including_auxilliary also includes the auxilliary variables in the output.\nshocks [Default: :all]: shocks for which to calculate the IRFs. Inputs can be either a Symbol (e.g. :y, :simulate, :none, or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol}, Vector{Symbol}, Matrix{Float64}, or KeyedArray{Float64}. :simulate triggers random draws of all shocks. A series of shocks can be passed on using either a Matrix{Float64}, or a KeyedArray{Float64} as input with shocks in rows and periods in columns. The period of the simulation will correspond to the length of the input in the period dimension + the number of periods defined in periods. If the series of shocks is input as a KeyedArray{Float64} make sure to name the rows with valid shock names of type Symbol. Any shocks not part of the model will trigger a warning. :none in combination with an initial_state can be used for deterministic simulations.\nnegative_shock [Default: false, Type: Bool]: calculate a negative shock. Relevant for generalised IRFs.\ngeneralised_irf [Default: false, Type: Bool]: calculate generalised IRFs. Relevant for nonlinear solutions. Reference steady state for deviations is the stochastic steady state.\ninitial_state [Default: [0.0], Type: Vector{Float64}]: provide state (in levels, not deviations) from which to start IRFs. Relevant for normal IRFs. The state includes all variables as well as exogenous variables in leads or lags if present.\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend;\n\n@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend;\n\nplot_irf(RBC)\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.plot_irfs","page":"API","title":"MacroModelling.plot_irfs","text":"See plot_irf\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.plot_simulations-Tuple","page":"API","title":"MacroModelling.plot_simulations","text":"Wrapper for plot_irf with shocks = :simulate and periods = 100.\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.plot_solution-Tuple{MacroModelling.‚Ñ≥, Symbol}","page":"API","title":"MacroModelling.plot_solution","text":"plot_solution(\n    ùìÇ,\n    state;\n    variables,\n    algorithm,\n    œÉ,\n    parameters,\n    show_plots,\n    save_plots,\n    save_plots_format,\n    save_plots_path,\n    plots_per_page,\n    verbose\n)\n\n\nPlot the solution of the model (mapping of past states to present variables) around the (non) stochastic steady state (depending on chosen solution algorithm). Each plot shows the relationship between the chosen state (defined in state) and one of the chosen variables (defined in variables). \n\nThe (non) stochastic steady state is plotted along with the mapping from the chosen past state to one present variable per plot. All other (non-chosen) states remain in the (non) stochastic steady state.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\nstate [Type: Symbol]: state variable to be shown on x-axis.\n\nKeyword Arguments\n\nvariables [Default: :all]: variables for which to show the results. Inputs can be either a Symbol (e.g. :y or :all), Tuple{Symbol, Vararg{Symbol}}, Matrix{Symbol} or Vector{Symbol}. Any variables not part of the model will trigger a warning. :all will contain all variables but not the auxilliary ones. all_including_auxilliary also includes the auxilliary variables in the output.\nalgorithm [Default: :first_order, Type: Union{Symbol,Vector{Symbol}}]: solution algorithm for which to show the IRFs. Can be more than one: [:second_order,:third_order]\"\nœÉ [Default: 2, Type: Union{Int64,Float64}]: defines the range of the state variable around the (non) stochastic steady state in standard deviations. E.g. a value of 2 means that the state variable is plotted for values of the (non) stochastic steady state in standard deviations +/- 2 standard deviations.\nparameters [Default: nothing]: If nothing is provided, the solution is calculated for the parameters defined previously. Acceptable inputs are a vector of parameter values, a vector or tuple of pairs of the parameter symbol and value. If the new parameter values differ from the previously defined the solution will be recalculated.\nshow_plots [Default: true, Type: Bool]: show plots. Separate plots per shocks and varibles depending on number of variables and plots_per_page.\nsave_plots [Default: false, Type: Bool]: switch to save plots using path and extension from save_plots_path and save_plots_format. Separate files per shocks and variables depending on number of variables and plots_per_page\nsave_plots_path [Default: pwd(), Type: String]: path where to save plots\nsave_plots_format [Default: :pdf, Type: Symbol]: output format of saved plots. See input formats compatible with GR for valid formats.\nplots_per_page [Default: 4, Type: Int]: how many plots to show per page\nverbose [Default: false, Type: Bool]: print information about how the NSSS is solved (symbolic or numeric), which solver is used (Levenberg-Marquardt...), and the maximum absolute error.\n\nExamples\n\nusing MacroModelling\n\n@model RBC_CME begin\n    y[0]=A[0]*k[-1]^alpha\n    1/c[0]=beta*1/c[1]*(alpha*A[1]*k[0]^(alpha-1)+(1-delta))\n    1/c[0]=beta*1/c[1]*(R[0]/Pi[+1])\n    R[0] * beta =(Pi[0]/Pibar)^phi_pi\n    A[0]*k[-1]^alpha=c[0]+k[0]-(1-delta*z_delta[0])*k[-1]\n    z_delta[0] = 1 - rho_z_delta + rho_z_delta * z_delta[-1] + std_z_delta * delta_eps[x]\n    A[0] = 1 - rhoz + rhoz * A[-1]  + std_eps * eps_z[x]\nend\n\n@parameters RBC_CME begin\n    alpha = .157\n    beta = .999\n    delta = .0226\n    Pibar = 1.0008\n    phi_pi = 1.5\n    rhoz = .9\n    std_eps = .0068\n    rho_z_delta = .9\n    std_z_delta = .005\nend\n\nplot_solution(RBC_CME, :k)\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.plotlyjs_backend","page":"API","title":"MacroModelling.plotlyjs_backend","text":"plotlyjs_backend()\n\nRenaming and reexport of Plot.jl function plotlyjs() to define PlotlyJS.jl as backend\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.simulate-Tuple","page":"API","title":"MacroModelling.simulate","text":"Wrapper for get_irf with shocks = :simulate.\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.std","page":"API","title":"MacroModelling.std","text":"Wrapper for get_moments with standard_deviation = true and non_stochastic_steady_state = false, variance = false, covariance = false.\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.translate_dynare_file","page":"API","title":"MacroModelling.translate_dynare_file","text":"See translate_mod_file\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.translate_mod_file-Tuple{AbstractString}","page":"API","title":"MacroModelling.translate_mod_file","text":"translate_mod_file(path_to_mod_file)\n\n\nReads in a dynare .mod-file, adapts the syntax, tries to capture parameter definitions, and writes a julia file in the same folder containing the model equations and parameters in MacroModelling.jl syntax. This function is not guaranteed to produce working code. It's purpose is to make it easier to port a model from dynare to MacroModelling.jl. \n\nThe recommended workflow is to use this function to translate a .mod-file, and then adapt the output so that it runs and corresponds to the input.\n\nArguments\n\npath_to_mod_file [Type: AbstractString]: path including filename of the .mod-file to be translated\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.var","page":"API","title":"MacroModelling.var","text":"Wrapper for get_moments with variance = true and non_stochastic_steady_state = false, standard_deviation = false, covariance = false.\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.write_dynare_file","page":"API","title":"MacroModelling.write_dynare_file","text":"See write_mod_file\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.write_mod_file-Tuple{MacroModelling.‚Ñ≥}","page":"API","title":"MacroModelling.write_mod_file","text":"write_mod_file(m)\n\n\nWrites a dynare .mod-file in the current working directory. This function is not guaranteed to produce working code. It's purpose is to make it easier to port a model from MacroModelling.jl to dynare. \n\nThe recommended workflow is to use this function to write a .mod-file, and then adapt the output so that it runs and corresponds to the input.\n\nArguments\n\nùìÇ: the object created by @model and @parameters for which to get the solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MacroModelling.write_to_dynare","page":"API","title":"MacroModelling.write_to_dynare","text":"See write_mod_file\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.write_to_dynare_file","page":"API","title":"MacroModelling.write_to_dynare_file","text":"See write_mod_file\n\n\n\n\n\n","category":"function"},{"location":"api/#MacroModelling.@model-Tuple{Any, Any}","page":"API","title":"MacroModelling.@model","text":"Parses the model equations and assigns them to an object.\n\nArguments\n\nùìÇ: name of the object to be created containing the model information.\nex: equations\n\nVariables must be defined with their time subscript in squared brackets. Endogenous variables can have the following:\n\npresent: c[0]\nnon-stcohastic steady state: c[ss] instead of ss any of the following is also a valid flag for the non-stochastic steady state: ss, stst, steady, steadystate, steady_state, and the parser is case-insensitive (SS or sTst will work as well).\npast: c[-1] or any negative Integer: e.g. c[-12]\nfuture: c[1] or any positive Integer: e.g. c[16] or c[+16]\n\nSigned integers are recognised and parsed as such.\n\nExogenous variables (shocks) can have the following:\n\npresent: c[x] instead of x any of the following is also a valid flag for exogenous variables: ex, exo, exogenous, and the parser is case-insensitive (Ex or exoGenous will work as well).\npast: c[x-1]\nfuture: c[x+1]\n\nParameters enter the equations without squared brackets.\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/#MacroModelling.@parameters-Tuple{Any, Vararg{Any}}","page":"API","title":"MacroModelling.@parameters","text":"Adds parameter values and calibration equations to the previously defined model.\n\nArguments\n\nùìÇ: name of the object previously created containing the model information.\nex: parameter, parameters values, and calibration equations\n\nParameters can be defined in either of the following ways:\n\nplain number: Œ¥ = 0.02\nexpression containing numbers: Œ¥ = 1/50\nexpression containing other parameters: Œ¥ = 2 * std_z in this case it is irrelevant if std_z is defined before or after. The definitons including other parameters are treated as a system of equaitons and solved accordingly.\nexpressions containing a target parameter and an equations with endogenous variables in the non-stochastic steady state, and other parameters, or numbers: k[ss] / (4 * q[ss]) = 1.5 | Œ¥ or Œ± | 4 * q[ss] = Œ¥ * k[ss] in this case the target parameter will be solved simultaneaously with the non-stochastic steady state using the equation defined with it.\n\nOptional arguments to be placed between ùìÇ and ex\n\nverbose [Default: false, Type: Bool]: print more information about how the non stochastic steady state is solved\nsilent [Default: false, Type: Bool]: do not print any information\nsymbolic [Default: false, Type: Bool]: try to solve the non stochastic steady state symbolically and fall back to a numerical solution if not possible\nperturbation_order [Default: 1, Type: Int]: take derivatives only up to the specified order at this stage. In case you want to work with higher order perturbation later on, respective derivatives will be taken at that stage.\n\nExamples\n\nusing MacroModelling\n\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend\n\n@parameters RBC verbose = true begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend\n\n\n\n\n\n","category":"macro"},{"location":"tutorials/install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"tutorials/install/","page":"Installation","title":"Installation","text":"MacroModelling.jl requires julia version 1.8 or higher and an IDE is recommended (e.g. VS Code with the julia extension).","category":"page"},{"location":"tutorials/install/","page":"Installation","title":"Installation","text":"Once set up you can install MacroModelling.jl by typing the following in the julia REPL:","category":"page"},{"location":"tutorials/install/","page":"Installation","title":"Installation","text":"using Pkg; Pkg.add(\"MacroModelling\")","category":"page"},{"location":"unfinished_docs/todo/#Todo-list","page":"Todo list","title":"Todo list","text":"","category":"section"},{"location":"unfinished_docs/todo/#High-priority","page":"Todo list","title":"High priority","text":"","category":"section"},{"location":"unfinished_docs/todo/","page":"Todo list","title":"Todo list","text":"[ ] add balanced growth path handling\n[ ] higher order solution derivs with Zygote\n[ ] custom LM: optimize for other RBC models, use third order backtracking\n[ ] use cache for gradient calc in estimation (see DifferentiableStateSpaceModels)\n[ ] use krylov instead of linearsolve and speed up sparse matrix calcs in implicit diff of higher order funcs\n[ ] improve docs: timing in first sentence seems off; have something more general in first sentence; why is the syntax user friendly? give an example; make the former and the latter a footnote\n[ ] add SSS for third order (can be different than the one from 2nd order, see Gali (2015)) in solution plot; also put legend to the bottom as with Condition\n[ ] weed out SS solver and saved objects\n[ ] streamline estimation part (dont do string matching... but rely on precomputed indices...)\n[ ] change docs to reflect that the output of irfs include aux vars and also the model info Base.show includes aux vars\n[ ] check out Aqua.jl as additional tests\n[ ] write functions to debug (fix_SS.jl...)\n[ ] parser model into per equation functions instead of single big functions\n[ ] model compression -> model setup as maximisation problem (gEcon) -> HANK models\n[ ] add other outputs from estimation (smoothed, filter states and shocks)\n[ ] implement global solution methods\n[ ] add more models\n[ ] plot multiple solutions or models - multioptions in one graph\n[ ] write tests and documentation for solution, estimation... making sure results are consistent\n[ ] write documentation/docstrings\n[ ] use @assert for errors and @test_throws\n[ ] print SS dependencies, show SS solver\n[ ] speed up 2nd moment calc for large models. maybe its only the derivatives but its slow for SW03\n[ ] make the nonnegativity trick optional\n[ ] get parameters (in function of parameters) into the dependencies\n[ ] for larger models write a model compression. gradient loglikelihood is very slow due to large matmuls\n[ ] see if we can avoid try catch and test for invertability instead\n[ ] use packages for kalman filter\n[ ] clean up different parameter types\n[ ] clean up printouts/reporting\n[ ] clean up function inputs and harmonise AD and standard commands\n[ ] figure out combinations for inputs (parameters and variables in different formats for get_irf for example)\n[ ] Find any SS by optimising over both SS guesses and parameter inputs\n[ ] have Flux solve SS field\n[ ] check control flow in SS solver\n[x] catch cases where you define calibration equation without declaring conditional variable\n[x] flag if equations contain no info for SS, suggest to set ss values as parameters\n[x] handle SS case where there are equations which have no information for the SS. use SS definitions in parameter block to complete system | no, set steady state values to parameters instead. might fail if redundant equation has y[0] - y[-1] instead of y[0] - y[ss]\n[x] try eval instead of runtimegeneratedfunctions; eval is slower but can be typed\n[x] check correctness of solution for models added\n[x] SpecialFunctions eta and gamma cause conflicts; consider importing used functions explicitly\n[x] bring the parsing of equations after the parameters macro\n[x] rewrite redundant var part so that it works with ssauxequations instead of ss_equations\n[x] catch cases where ss vars are set to zero. x[0] * eps_z[x] in SS becomes x[0] * 0 but should be just 0 (use sympy for this)\n[x] remove duplicate nonnegative aux vars to speed up SS solver\n[x] error when defining variable more than once in parameters macro\n[x] consolidate aux vars, use sympy to simplify\n[x] error when writing equations with only one variable\n[x] error when defining variable as parameter\n[x] more options for IRFs, simulate only certain shocks - set stds to 0 instead\n[x] add NBTOOLBOX, IRIS to overview\n[x] input field for SS init guess in all functions #not necessary so far. SS solver works out everything just fine\n[x] symbolic derivatives\n[x] check SW03 SS solver\n[x] more options for IRFs, pass on shock vector\n[x] write to dynare\n[x] add plot for policy function\n[x] add plot for FEVD\n[x] add functions like getvariance, getsd, getvar, getcovar\n[x] add correlation, autocorrelation, and (conditional) variance decomposition\n[x] go through docs to reflect verbose behaviour\n[x] speed up covariance mat calc\n[x] have conditional parameters at end of entry as well (... | alpha instead of alpha | ...)\n[x] Get functions: getoutput, getmoments\n[x] get rid of init_guess\n[x] an and schorfheide estimation\n[x] estimation, IRF matching, system priors\n[x] check derivative tests with finite diff\n[x] release first version\n[x] SS solve: add domain transformation optim\n[x] revisit optimizers for SS\n[x] figure out licenses\n[x] SS: replace variables in log() with auxilliary variable which must be positive to help solver\n[x] complex example with lags > 1, [ss], calib equations, aux nonneg vars\n[x] add NLboxsolve\n[x] try NonlinearSolve - fails due to missing bounds\n[x] make noneg aux part of optim problem for NLboxsolve in order to avoid DomainErrors - not necessary\n[x] have bounds on alpha (failed previously due to naming conflict) - works now","category":"page"},{"location":"unfinished_docs/todo/#Not-high-priority","page":"Todo list","title":"Not high priority","text":"","category":"section"},{"location":"unfinished_docs/todo/","page":"Todo list","title":"Todo list","text":"[ ] estimation codes with missing values (adopt kalman filter)\n[ ] whats a good error measure for higher order solutions (taking whole dist of future shock into account)? use mean error for n number of future shocks\n[ ] improve redundant calculations of SS and other parts of solution\n[ ] restructure functions and containers so that compiler knows what types to expect\n[ ] use RecursiveFactorization and TriangularSolve to solve, instead of MKL or OpenBLAS\n[ ] fix SnoopCompile with generated functions\n[ ] rewrite first order with riccati equation MatrixEquations.jl\n[ ] exploit variable incidence and compression for higher order derivatives\n[ ] for estimation use CUDA with st order: linear time iteration starting from last 1st order solution and then LinearSolveCUDA solvers for higher orders. this should bring benefits for large models and HANK models\n[ ] test on highly nonlinear model\n[ ] pull request in StatsFuns to have norminv... accept type numbers and add translation from matlab: norminv to StatsFuns norminvcdf\n[ ] more informative errors when declaring equations/ calibration\n[ ] unit equation errors\n[ ] implenent reduced linearised system solver + nonlinear\n[ ] implement HANK\n[ ] implement automatic problem derivation (gEcon)\n[ ] print legend for algorithm in last subplot of plot only\n[ ] select variables for moments\n[x] conditional forecasting\n[x] find way to recover from failed SS solution which is written to init guess\n[x] redo ugly solution for selecting parameters to differentiate for\n[x] conditions for when to use which solution. if solution is outdated redo all solutions which have been done so far and use smart starting points\n[x] Revise 2,3 pert codes to make it more intuitive\n[x] implement blockdiag with julia package instead of python\n[x] Pretty print linear solution\n[x] write function to get_irfs\n[x] Named arrays for irf\n[x] write state space function for solution\n[x] Status print for model container\n[x] implenent 2nd + 3rd order perturbation\n[x] implement fuctions for distributions\n[x] try speedmapping.jl - no improvement\n[x] moment matching\n[x] write tests for higher order pert and standalone function\n[x] add compression back in\n[x] FixedPointAcceleration didnt improve on iterative procedure\n[x] add exogenous variables in lead or lag\n[x] regex in parser of SS and exo\n[x] test SS solver on SW07\n[x] change calibration, distinguish SS/dyn parameters\n[x] plot multiple solutions at same time (save them in separate constructs)\n[x] implement bounds in SS finder\n[x] map pars + vars impacting SS\n[x] check bounds when putting in new calibration\n[x] Save plot option\n[x] Add shock to plot title\n[x] print model name","category":"page"},{"location":"tutorials/rbc/#Write-your-first-model-simple-RBC","page":"RBC","title":"Write your first model - simple RBC","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The following tutorial will walk you through the steps of writing down a model (not explained here / taken as given) and analysing it. Prior knowledge of DSGE models and their solution in practical terms (e.g. having used a mod file with dynare) is useful in understanding this tutorial.","category":"page"},{"location":"tutorials/rbc/#Define-the-model","page":"RBC","title":"Define the model","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The first step is always to name the model and write down the equations. Taking a standard real business cycle (RBC) model this would go as follows.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"First, we load the package and then use the @model macro to define our model. The first argument after @model is the model name and will be the name of the object in the global environment containing all information regarding the model. The second argument to the macro are the equations, which we write down between begin and end. One equation per line and timing of endogenous variables are expressed in the squared brackets following the variable name. Exogenous variables (shocks) are followed by a keyword in squared brackets indicating them being exogenous (in this case [x]). Note that names can leverage julias unicode capabilities (alpha can be written as Œ±).","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"ENV[\"GKSwstype\"] = \"100\"","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"using MacroModelling\n@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"After the model is parsed we get some info on the model variables, and parameters.","category":"page"},{"location":"tutorials/rbc/#Define-the-parameters","page":"RBC","title":"Define the parameters","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Next we need to add the parameters of the model. The macro @parameters takes care of this:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"@parameters RBC begin\n    std_z = 0.01\n    œÅ = 0.2\n    Œ¥ = 0.02\n    Œ± = 0.5\n    Œ≤ = 0.95\nend","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Parameter definitions are similar to assigning values in julia. Note that we have to write one parameter definition per line.","category":"page"},{"location":"tutorials/rbc/#Plot-impulse-response-functions-(IRFs)","page":"RBC","title":"Plot impulse response functions (IRFs)","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Given the equations and parameters, we have everything to solve the model and do some analysis. A common output are IRFs for the exogenous shocks. Calling plot_irf (different names for the same function are also supported: plot_irfs, or plot_IRF) will take care of this. In the background the package solves (symbolically in this simple case) for the non stochastic steady state (SS) and calculates the first order perturbation solution.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"plot_irf(RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"(Image: RBC IRF)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"When the model is solved the first time (in this case by calling plot_irf), the package breaks down the steady state problem into independent blocks and first attempts to solve them symbolically and if that fails numerically.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The plot shows the responses of the endogenous variables (c, k, q, and z) to a one standard deviation positive (indicated by Shock‚Å∫ in chart title) unanticipated shock in  eps_z. Therefore there are as many subplots as there are combinations of shocks and endogenous variables (which are impacted by the shock). Plots are composed of up to 9 subplots and the plot title shows the model name followed by the name of the shock and which plot we are seeing out of the plots for this shock (e.g. (1/3) means we see the first out of three plots for this shock). Subplots show the sorted endogenous variables with the left y-axis showing the level of the respective variable and the right y-axis showing the percent deviation from the SS (if variable is strictly positive). The horizontal black line marks the SS.","category":"page"},{"location":"tutorials/rbc/#Explore-other-parameter-values","page":"RBC","title":"Explore other parameter values","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Playing around with the model can be especially insightful in the early phase of model development. The package tries to facilitates this process to the extent possible. Typically one wants to try different parameter values and see how the IRFs change. This can be done by using the parameters argument of the plot_irf function. We pass a Pair with the Symbol of the parameter (: in front of the parameter name) we want to change and its new value to the parameter argument (e.g. :Œ± => 0.3).","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"plot_irf(RBC, parameters = :Œ± => 0.3)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"(Image: IRF plot)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"First, the package finds the new steady state, solves the model dynamics around it and saves the new parameters and solution in the model object. Second, note that the shape of the curves in the plot and the y-axis values changed. Updating the plot for new parameters is significantly faster than calling it the first time. This is because the first call triggers compilations of the model functions, and once compiled the user benefits from the performance of the specialised compiled code.","category":"page"},{"location":"tutorials/rbc/#Plot-model-simulation","page":"RBC","title":"Plot model simulation","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Another insightful output is simulations of the model. Here we can use the plot_simulations function. To the same effect we can use the plot_irf function and specify in the shocks argument that we want to :simulate the model and set the periods argument to 100.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"plot_simulations(RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"(Image: Simulate RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The plots show the models endogenous variables in response to random draws for all exogenous shocks over 100 periods.","category":"page"},{"location":"tutorials/rbc/#Plot-specific-series-of-shocks","page":"RBC","title":"Plot specific series of shocks","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Sometimes one has a specific series of shocks in mind and wants to see the corresponding model response of endogenous variables. This can be achieved by passing a Matrix or KeyedArray of the series of shocks to the shocks argument of the plot_irf function:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"shock_series = zeros(1,4)\nshock_series[1,2] = 1\nshock_series[1,4] = -1\nplot_irf(RBC, shocks = shock_series)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"(Image: Series of shocks RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The plot shows the two shocks hitting the economy in periods 2 and 4 and then continues the simulation for 40 more quarters.","category":"page"},{"location":"tutorials/rbc/#Model-statistics","page":"RBC","title":"Model statistics","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The package solves for the SS automatically and we got an idea of the SS values in the plots. If we want to see the SS values we can call get_steady_state:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"get_steady_state(RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"to get the SS and the derivatives of the SS with respect to the model parameters. The first column of the returned matrix shows the SS while the second to last columns show the derivatives of the SS values (indicated in the rows) with respect to the parameters (indicated in the columns). For example, the derivative of k with respect to Œ≤ is 165.319. This means that if we increase Œ≤ by 1, k would increase by 165.319 approximately. Let's see how this plays out by changing Œ≤ from 0.95 to 0.951 (a change of +0.001):","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"get_steady_state(RBC,parameters = :Œ≤ => .951)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Note that get_steady_state like all other get functions has the parameters argument. Hence, whatever output we are looking at we can change the parameters of the model.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The new value of Œ≤ changed the SS as expected and k increased by 0.168. The elasticity (0.168/0.001) comes close to the partial derivative previously calculated. The derivatives help understanding the effect of parameter changes on the steady state and make for easier navigation of the parameter space.","category":"page"},{"location":"tutorials/rbc/#Standard-deviations","page":"RBC","title":"Standard deviations","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Next to the SS we can also show the model implied standard deviations of the model. get_standard_deviation takes care of this. Additionally we will set the parameter values to what they were in the beginning by passing on a Tuple of Pairs containing the Symbols of the parameters to be changed and their new (initial) values (e.g. (:Œ± => 0.5, :Œ≤ => .95)).","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"get_standard_deviation(RBC, parameters = (:Œ± => 0.5, :Œ≤ => .95))","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The function returns the model implied standard deviations of the model variables and their derivatives with respect to the model parameters. For example, the derivative of the standard deviation of c with resect to Œ¥ is -0.384. In other words, the standard deviation of c decreases with increasing Œ¥.","category":"page"},{"location":"tutorials/rbc/#Correlations","page":"RBC","title":"Correlations","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Another useful statistic is the model implied correlation of variables. We use get_correlation for this:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"get_correlation(RBC)","category":"page"},{"location":"tutorials/rbc/#Autocorrelations","page":"RBC","title":"Autocorrelations","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Last but not least, we have a look at the model implied autocorrelations of model variables using the get_autocorrelation function:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"get_autocorrelation(RBC)","category":"page"},{"location":"tutorials/rbc/#Model-solution","page":"RBC","title":"Model solution","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"A further insightful output are the policy and transition functions of the the first order perturbation solution. To retrieve the solution we call the function get_solution:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"get_solution(RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The solution provides information about how past states and present shocks impact present variables. The first row contains the SS for the variables denoted in the columns. The second to last rows contain the past states, with the time index ‚Çç‚Çã‚ÇÅ‚Çé, and present shocks, with exogenous variables denoted by ‚Çç‚Çì‚Çé. For example, the immediate impact of a shock to eps_z on q is 0.0688.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"There is also the possibility to visually inspect the solution using the plot_solution function:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"plot_solution(RBC, :k)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"(Image: RBC solution)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The chart shows the first order perturbation solution mapping from the past state k to the present variables of the model. The state variable covers a range of two standard deviations around the non stochastic steady state and all other states remain in the non stochastic steady state.","category":"page"},{"location":"tutorials/rbc/#Obtain-array-of-IRFs-or-model-simulations","page":"RBC","title":"Obtain array of IRFs or model simulations","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Last but not least the user might want to obtain simulated time series of the model or IRFs without plotting them. For IRFs this is possible by calling get_irf:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"get_irf(RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"which returns a 3-dimensional KeyedArray with variables in rows, the period in columns, and the shocks as the third dimension.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"For simulations this is possible by calling simulate:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"simulate(RBC)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"which returns the simulated data in a 3-dimensional KeyedArray of the same structure as for the IRFs.","category":"page"},{"location":"tutorials/rbc/#Conditional-forecasts","page":"RBC","title":"Conditional forecasts","text":"","category":"section"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Conditional forecasting is a useful tool to incorporate for example forecasts into a model and then add shocks on top.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"For example we might be interested in the model dynamics given a path for c for the first 4 quarters and the next quarter a negative shock to eps_z arrives. This can be implemented using the get_conditional_forecast function and visualised with the plot_conditional_forecast function.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"First, we define the conditions on the endogenous variables as deviations from the non stochastic steady state (c in this case) using a KeyedArray from the AxisKeys package (check get_conditional_forecast for other ways to define the conditions):","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"using AxisKeys\nconditions = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,1,4),Variables = [:c], Periods = 1:4)\nconditions[1:4] .= [-.01,0,.01,.02];","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Note that all other endogenous variables not part of the KeyedArray are also not conditioned on.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Next, we define the conditions on the shocks (eps_z in this case) using a SparseArrayCSC from the SparseArrays package (check get_conditional_forecast for other ways to define the conditions on the shocks):","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"using SparseArrays\nshocks = spzeros(1,5)\nshocks[1,5] = -1;","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Note that for the first 4 periods the shock has no predetermined value and is determined by the conditions on the endogenous variables.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Finally we can get the conditional forecast:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"get_conditional_forecast(RBC, conditions, shocks = shocks)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"The function returns a KeyedArray with the values of the endogenous variables and shocks matching the conditions exactly.","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"We can also plot the conditional forecast using:","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"plot_conditional_forecast(RBC, conditions, shocks = shocks)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"(Image: RBC conditional forecast)","category":"page"},{"location":"tutorials/rbc/","page":"RBC","title":"RBC","text":"Note that the stars indicate the values the model is conditioned on.","category":"page"},{"location":"tutorials/estimation/#Estimate-a-simple-model-Schorfheide-(2000)","page":"Estimation","title":"Estimate a simple model - Schorfheide (2000)","text":"","category":"section"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"This tutorial is intended to show the workflow to estimate a model using the No-U-Turn sampler (NUTS). The tutorial works with a benchmark model for estimation and can therefore be compared to results from other software packages (e.g. dynare).","category":"page"},{"location":"tutorials/estimation/#Define-the-model","page":"Estimation","title":"Define the model","text":"","category":"section"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"The first step is always to name the model and write down the equations. For the Schorfheide (2000) model this would go as follows:","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"ENV[\"GKSwstype\"] = \"100\"\nusing Random\nRandom.seed!(30)","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"using MacroModelling\n\n@model FS2000 begin\n    dA[0] = exp(gam + z_e_a  *  e_a[x])\n\n    log(m[0]) = (1 - rho) * log(mst)  +  rho * log(m[-1]) + z_e_m  *  e_m[x]\n\n    - P[0] / (c[1] * P[1] * m[0]) + bet * P[1] * (alp * exp( - alp * (gam + log(e[1]))) * k[0] ^ (alp - 1) * n[1] ^ (1 - alp) + (1 - del) * exp( - (gam + log(e[1])))) / (c[2] * P[2] * m[1])=0\n\n    W[0] = l[0] / n[0]\n\n    - (psi / (1 - psi)) * (c[0] * P[0] / (1 - n[0])) + l[0] / n[0] = 0\n\n    R[0] = P[0] * (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ ( - alp) / W[0]\n\n    1 / (c[0] * P[0]) - bet * P[0] * (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ (1 - alp) / (m[0] * l[0] * c[1] * P[1]) = 0\n\n    c[0] + k[0] = exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ (1 - alp) + (1 - del) * exp( - (gam + z_e_a  *  e_a[x])) * k[-1]\n\n    P[0] * c[0] = m[0]\n\n    m[0] - 1 + d[0] = l[0]\n\n    e[0] = exp(z_e_a  *  e_a[x])\n\n    y[0] = k[-1] ^ alp * n[0] ^ (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x]))\n\n    gy_obs[0] = dA[0] * y[0] / y[-1]\n\n    gp_obs[0] = (P[0] / P[-1]) * m[-1] / dA[0]\n\n    log_gy_obs[0] = log(gy_obs[0])\n\n    log_gp_obs[0] = log(gp_obs[0])\nend","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"First, we load the package and then use the @model macro to define our model. The first argument after @model is the model name and will be the name of the object in the global environment containing all information regarding the model. The second argument to the macro are the equations, which we write down between begin and end. Equations can contain an equality sign or the expression is assumed to equal 0. Equations cannot span multiple lines and the timing of endogenous variables are expressed in the squared brackets following the variable name (e.g. [-1] for the past period). Exogenous variables (shocks) are followed by a keyword in squared brackets indicating them being exogenous (in this case [x]). Note that names can leverage julia's unicode capabilities (e.g. alpha can be written as Œ±).","category":"page"},{"location":"tutorials/estimation/#Define-the-parameters","page":"Estimation","title":"Define the parameters","text":"","category":"section"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"Next we need to add the parameters of the model. The macro @parameters takes care of this:","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"@parameters FS2000 begin  \n    alp     = 0.356\n    bet     = 0.993\n    gam     = 0.0085\n    mst     = 1.0002\n    rho     = 0.129\n    psi     = 0.65\n    del     = 0.01\n    z_e_a   = 0.035449\n    z_e_m   = 0.008862\nend","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"The block defining the parameters above only describes the simple parameter definitions the same way you assign values (e.g. alp = .356).","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"Note that we have to write one parameter definition per line.","category":"page"},{"location":"tutorials/estimation/#Load-data,-declare-observables,-and-write-moments-mapping-to-distribution-parameters","page":"Estimation","title":"Load data, declare observables, and write moments mapping to distribution parameters","text":"","category":"section"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"Given the equations and parameters, we only need the data and define the observables to be able to estimate the model. First, we load in the data from a CSV file (using the CSV and DataFrames packages) and convert it to a KeyedArray (using the AxisKeys package). Furthermore, we log transform the data provided in levels, and define the observables of the model. Last but not least we select only those variables in the data which are declared observables in the model.","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"using CSV, DataFrames, AxisKeys\n\n# load data\ndat = CSV.read(\"../assets/FS2000_data.csv\", DataFrame)\ndata = KeyedArray(Array(dat)',Variable = Symbol.(\"log_\".*names(dat)),Time = 1:size(dat)[1])\ndata = log.(data)\n\n# declare observables\nobservables = sort(Symbol.(\"log_\".*names(dat)))\n\n# subset observables in data\ndata = data(observables,:)","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"In order to make the prior definitions more intuitive for users we define helper functions translating the mean and standard deviation of the beta, inverse gamma, and gamma distributions to the respective distribution parameters (e.g. Œ± and Œ≤ for the beta distribution).","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"# functions to map mean and standard deviations to distribution parameters\nfunction beta_map(Œº, œÉ) \n    Œ± = ((1 - Œº) / œÉ ^ 2 - 1 / Œº) * Œº ^ 2\n    Œ≤ = Œ± * (1 / Œº - 1)\n    return Œ±, Œ≤\nend\n\nfunction inv_gamma_map(Œº, œÉ)\n    Œ± = (Œº / œÉ) ^ 2 + 2\n    Œ≤ = Œº * ((Œº / œÉ) ^ 2 + 1)\n    return Œ±, Œ≤\nend\n\nfunction gamma_map(Œº, œÉ)\n    k = Œº^2/œÉ^2 \n    Œ∏ = œÉ^2 / Œº\n    return k, Œ∏\nend","category":"page"},{"location":"tutorials/estimation/#Define-bayesian-model","page":"Estimation","title":"Define bayesian model","text":"","category":"section"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"Next we define the parameter priors using the Turing package. The @model macro of the Turing package allows us to define the prior distributions over the parameters and combine it with the loglikelihood of the model and parameters given the data with the help of the calculate_kalman_filter_loglikelihood function. Inside the macro we first define the priors using distributions of the Distributions package (reexported by Turing) and the previously defined helper functions. See the documentation of the Turing package for more details. Next, we define the loglikelihood and add it to the posterior loglikelihood with the help of the @addlogprob! macro.","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"import Turing\nimport Turing: Normal, Beta, InverseGamma, NUTS, sample, logpdf\n\nTuring.@model function FS2000_loglikelihood_function(data, m, observables)\n    alp     ~ Beta(beta_map(0.356, 0.02)...)\n    bet     ~ Beta(beta_map(0.993, 0.002)...)\n    gam     ~ Normal(0.0085, 0.003)\n    mst     ~ Normal(1.0002, 0.007)\n    rho     ~ Beta(beta_map(0.129, 0.223)...)\n    psi     ~ Beta(beta_map(0.65, 0.05)...)\n    del     ~ Beta(beta_map(0.01, 0.005)...)\n    z_e_a   ~ InverseGamma(inv_gamma_map(0.035449, Inf)...)\n    z_e_m   ~ InverseGamma(inv_gamma_map(0.008862, Inf)...)\n\n    Turing.@addlogprob! calculate_kalman_filter_loglikelihood(m, data(observables), observables; parameters = [alp, bet, gam, mst, rho, psi, del, z_e_a, z_e_m])\nend","category":"page"},{"location":"tutorials/estimation/#Sample-from-posterior:-No-U-Turn-Sampler-(NUTS)","page":"Estimation","title":"Sample from posterior: No-U-Turn Sampler (NUTS)","text":"","category":"section"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"We use the NUTS sampler to retrieve the posterior distribution of the parameters. This sampler uses the gradient of the posterior loglikelihood with respect to the model parameters to navigate the parameter space. The NUTS sampler is considered robust, fast, and user-friendly (auto-tuning of hyper-parameters).","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"First we define the loglikelihood model with the specific data, observables, and model. Next, we draw 1000 samples from the model:","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"FS2000_loglikelihood = FS2000_loglikelihood_function(data, FS2000, observables)\n\nn_samples = 1000\n\nchain_NUTS  = sample(FS2000_loglikelihood, NUTS(), n_samples, progress = false);","category":"page"},{"location":"tutorials/estimation/#Inspect-posterior","page":"Estimation","title":"Inspect posterior","text":"","category":"section"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"In order to understand the posterior distribution and the sequence of sample we are plot them:","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"using StatsPlots\nStatsPlots.plot(chain_NUTS);","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"(Image: NUTS chain)","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"Next, we are plotting the posterior loglikelihood along two parameters dimensions, with the other parameters ket at the posterior mean, and add the samples to the visualisation. This visualisation allows us to understand the curvature of the posterior and puts the samples in context.","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"using ComponentArrays, MCMCChains, DynamicPPL, Plots\n\nparameter_mean = mean(chain_NUTS)\npars = ComponentArray(parameter_mean.nt[2],Axis(parameter_mean.nt[1]))\n\nlogjoint(FS2000_loglikelihood, pars)\n\nfunction calculate_log_probability(par1, par2, pars_syms, orig_pars, model)\n    orig_pars[pars_syms] = [par1, par2]\n    logjoint(model, orig_pars)\nend\n\ngranularity = 32;\n\npar1 = :del;\npar2 = :gam;\npar_range1 = collect(range(minimum(chain_NUTS[par1]), stop = maximum(chain_NUTS[par1]), length = granularity));\npar_range2 = collect(range(minimum(chain_NUTS[par2]), stop = maximum(chain_NUTS[par2]), length = granularity));\n\np = surface(par_range1, par_range2, \n            (x,y) -> calculate_log_probability(x, y, [par1, par2], pars, FS2000_loglikelihood),\n            camera=(30, 65),\n            colorbar=false,\n            color=:inferno);\n\n\njoint_loglikelihood = [logjoint(FS2000_loglikelihood, ComponentArray(reduce(hcat, get(chain_NUTS, FS2000.parameters)[FS2000.parameters])[s,:], Axis(FS2000.parameters))) for s in 1:length(chain_NUTS)]\n\nscatter3d!(vec(collect(chain_NUTS[par1])),\n           vec(collect(chain_NUTS[par2])),\n           joint_loglikelihood,\n            mc = :viridis, \n            marker_z = collect(1:length(chain_NUTS)), \n            msw = 0,\n            legend = false, \n            colorbar = false, \n            xlabel = string(par1),\n            ylabel = string(par2),\n            zlabel = \"Log probability\",\n            alpha = 0.5);\n\np","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"(Image: Posterior surface)","category":"page"},{"location":"tutorials/estimation/#Find-posterior-mode","page":"Estimation","title":"Find posterior mode","text":"","category":"section"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"Other than the mean and median of the posterior distribution we can also calculate the mode. To this end we will use optimisation routines from the Optimization, OptimizationNLopt, and OptimizationOptimisers packages.","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"First, we define the posterior loglikelihood function, similar to how we defined it for the Turing model macro.","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"function calculate_posterior_loglikelihood(parameters, u)\n    alp, bet, gam, mst, rho, psi, del, z_e_a, z_e_m = parameters\n    log_lik = 0\n    log_lik -= calculate_kalman_filter_loglikelihood(FS2000, data(observables), observables; parameters = parameters)\n    log_lik -= logpdf(Beta(beta_map(0.356, 0.02)...),alp)\n    log_lik -= logpdf(Beta(beta_map(0.993, 0.002)...),bet)\n    log_lik -= logpdf(Normal(0.0085, 0.003),gam)\n    log_lik -= logpdf(Normal(1.0002, 0.007),mst)\n    log_lik -= logpdf(Beta(beta_map(0.129, 0.223)...),rho)\n    log_lik -= logpdf(Beta(beta_map(0.65, 0.05)...),psi)\n    log_lik -= logpdf(Beta(beta_map(0.01, 0.005)...),del)\n    log_lik -= logpdf(InverseGamma(inv_gamma_map(0.035449, Inf)...),z_e_a)\n    log_lik -= logpdf(InverseGamma(inv_gamma_map(0.008862, Inf)...),z_e_m)\n    return log_lik\nend","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"Next, we set up the optimisation problem and first use the ADAM global optimiser for 1000 iterations in order to avoid local optima and then fine tune with L-BFGS.","category":"page"},{"location":"tutorials/estimation/","page":"Estimation","title":"Estimation","text":"using Optimization, OptimizationNLopt, OptimizationOptimisers\n\nf = OptimizationFunction(calculate_posterior_loglikelihood, Optimization.AutoForwardDiff())\n\nprob = OptimizationProblem(f, collect(pars), []);\nsol = solve(prob, Optimisers.Adam(), maxiters = 1000)\nsol.minimum\n\nlbs = fill(-1e12, length(FS2000.parameters));\nubs = fill(1e12, length(FS2000.parameters));\n\nbounds_index_in_pars = indexin(intersect(FS2000.bounded_vars,FS2000.parameters),FS2000.parameters);\nbounds_index_in_bounds = indexin(intersect(FS2000.bounded_vars,FS2000.parameters),FS2000.bounded_vars);\n\nlbs[bounds_index_in_pars] = max.(-1e12,FS2000.lower_bounds[bounds_index_in_bounds]);\nubs[bounds_index_in_pars] = min.(1e12,FS2000.upper_bounds[bounds_index_in_bounds]);\n\nprob = OptimizationProblem(f, min.(max.(sol.u,lbs),ubs), [], lb = lbs, ub = ubs);\nsol = solve(prob, NLopt.LD_LBFGS())\nsol.minimum","category":"page"},{"location":"#MacroModelling.jl","page":"Introduction","title":"MacroModelling.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Author: Thore Kockerols (@thorek1)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The goal of MacroModelling.jl is to reduce coding time and speed up model development.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The package supports dicsrete-time DSGE models and the timing of a variable reflects when the variable is decided (end of period for stock variables).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As of now the package can:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"parse a model written with user friendly syntax (variables are followed by time indices ...[2], [1], [0], [-1], [-2]..., or [x] for shocks)\n(tries to) solve the model only knowing the model equations and parameter values (no steady state file needed)\ncalculate first, second, and third order perturbation solutions using (forward or reverse-mode) automatic differentiation (AD)\ncalculate (generalised) impulse response functions, simulate the model, or do conditional forecasts\ncalibrate parameters using (non stochastic) steady state relationships\nmatch model moments\nestimate the model on data (Kalman filter using first order perturbation)\ndifferentiate (forward AD) the model solution (first order perturbation), Kalman filter loglikelihood (reverse-mode AD), model moments, steady state, with respect to the parameters","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The package is not:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"guaranteed to find the non stochastic steady state\nthe fastest package around if you already have a fast way to find the NSSS","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The former has to do with the fact that solving systems of nonlinear equations is hard (an active area of research). Especially in cases where the values of the solution are far apart (have a high standard deviation - e.g. sol = [-46.324, .993457, 23523.3856]), the algorithms have a hard time finding a solution. The recommended way to tackle this is to set bounds in the @parameters part (e.g. r < 0.2), so that the initial points are closer to the final solution (think of steady state interest rates not being higher than 20% - meaning not being higher than 0.2 or 1.2 depending on the definition).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The latter has to do with the fact that julia code is fast once compiled, and that the package can spend more time finding the non stochastic steady state. This means that it takes more time from executing the code to define the model and parameters for the first time to seeing the first plots than with most other packages. But, once the functions are compiled and the non stochastic steady state has been found the user can benefit from the object oriented nature of the package and generate outputs or change parameters very fast.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The package contains the following models in the models folder:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Aguiar and Gopinath (2007) Aguiar_Gopinath_2007.jl\nAscari and Sbordone (2014) Ascari_sbordone_2014.jl\nCaldara et al. (2012) Caldara_et_al_2012.jl\nGali (2015) - Chapter 3 Gali_2015_chapter_3_nonlinear.jl\nGali and Monacelli (2005) - CPI inflation-based Taylor rule Gali_Monacelli_2005_CITR.jl\nGerali, Neri, Sessa, and Signoretti (2010) GNSS_2010.jl\nGhironi and Melitz (2005) Ghironi_Melitz_2005.jl\nIreland (2004) Ireland_2004.jl\nJermann and Quadrini (2012) - RBC JQ_2012_RBC.jl\nNew Area-Wide Model (2008) - Euro Area - US NAWM_EAUS_2008.jl\nSchmitt-Groh√© and Uribe (2003) - debt premium SGU_2003_debt_premium.jl\nSchorfheide (2000) FS2000.jl\nSmets and Wouters (2003) SW03.jl\nSmets and Wouters (2007) SW07.jl","category":"page"},{"location":"tutorials/sw03/#Work-with-a-complex-model-Smets-and-Wouters-(2003)","page":"Smets and Wouters (2003)","title":"Work with a complex model - Smets and Wouters (2003)","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"This tutorial is intended to show more advanced features of the package which come into play with more complex models. The tutorial will walk through the same steps as for the simple RBC model but will use the nonlinear Smets and Wouters (2003) model instead. Prior knowledge of DSGE models and their solution in practical terms (e.g. having used a mod file with dynare) is useful in understanding this tutorial.","category":"page"},{"location":"tutorials/sw03/#Define-the-model","page":"Smets and Wouters (2003)","title":"Define the model","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The first step is always to name the model and write down the equations. For the Smets and Wouters (2003) model this would go as follows:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"ENV[\"GKSwstype\"] = \"100\"","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"using MacroModelling\n@model SW03 begin\n    -q[0] + beta * ((1 - tau) * q[1] + epsilon_b[1] * (r_k[1] * z[1] - psi^-1 * r_k[ss] * (-1 + exp(psi * (-1 + z[1])))) * (C[1] - h * C[0])^(-sigma_c))\n    -q_f[0] + beta * ((1 - tau) * q_f[1] + epsilon_b[1] * (r_k_f[1] * z_f[1] - psi^-1 * r_k_f[ss] * (-1 + exp(psi * (-1 + z_f[1])))) * (C_f[1] - h * C_f[0])^(-sigma_c))\n    -r_k[0] + alpha * epsilon_a[0] * mc[0] * L[0]^(1 - alpha) * (K[-1] * z[0])^(-1 + alpha)\n    -r_k_f[0] + alpha * epsilon_a[0] * mc_f[0] * L_f[0]^(1 - alpha) * (K_f[-1] * z_f[0])^(-1 + alpha)\n    -G[0] + T[0]\n    -G[0] + G_bar * epsilon_G[0]\n    -G_f[0] + T_f[0]\n    -G_f[0] + G_bar * epsilon_G[0]\n    -L[0] + nu_w[0]^-1 * L_s[0]\n    -L_s_f[0] + L_f[0] * (W_i_f[0] * W_f[0]^-1)^(lambda_w^-1 * (-1 - lambda_w))\n    L_s_f[0] - L_f[0]\n    L_s_f[0] + lambda_w^-1 * L_f[0] * W_f[0]^-1 * (-1 - lambda_w) * (-W_disutil_f[0] + W_i_f[0]) * (W_i_f[0] * W_f[0]^-1)^(-1 + lambda_w^-1 * (-1 - lambda_w))\n    Pi_ws_f[0] - L_s_f[0] * (-W_disutil_f[0] + W_i_f[0])\n    Pi_ps_f[0] - Y_f[0] * (-mc_f[0] + P_j_f[0]) * P_j_f[0]^(-lambda_p^-1 * (1 + lambda_p))\n    -Q[0] + epsilon_b[0]^-1 * q[0] * (C[0] - h * C[-1])^(sigma_c)\n    -Q_f[0] + epsilon_b[0]^-1 * q_f[0] * (C_f[0] - h * C_f[-1])^(sigma_c)\n    -W[0] + epsilon_a[0] * mc[0] * (1 - alpha) * L[0]^(-alpha) * (K[-1] * z[0])^alpha\n    -W_f[0] + epsilon_a[0] * mc_f[0] * (1 - alpha) * L_f[0]^(-alpha) * (K_f[-1] * z_f[0])^alpha\n    -Y_f[0] + Y_s_f[0]\n    Y_s[0] - nu_p[0] * Y[0]\n    -Y_s_f[0] + Y_f[0] * P_j_f[0]^(-lambda_p^-1 * (1 + lambda_p))\n    beta * epsilon_b[1] * (C_f[1] - h * C_f[0])^(-sigma_c) - epsilon_b[0] * R_f[0]^-1 * (C_f[0] - h * C_f[-1])^(-sigma_c)\n    beta * epsilon_b[1] * pi[1]^-1 * (C[1] - h * C[0])^(-sigma_c) - epsilon_b[0] * R[0]^-1 * (C[0] - h * C[-1])^(-sigma_c)\n    Y_f[0] * P_j_f[0]^(-lambda_p^-1 * (1 + lambda_p)) - lambda_p^-1 * Y_f[0] * (1 + lambda_p) * (-mc_f[0] + P_j_f[0]) * P_j_f[0]^(-1 - lambda_p^-1 * (1 + lambda_p))\n    epsilon_b[0] * W_disutil_f[0] * (C_f[0] - h * C_f[-1])^(-sigma_c) - omega * epsilon_b[0] * epsilon_L[0] * L_s_f[0]^sigma_l\n    -1 + xi_p * (pi[0]^-1 * pi[-1]^gamma_p)^(-lambda_p^-1) + (1 - xi_p) * pi_star[0]^(-lambda_p^-1)\n    -1 + (1 - xi_w) * (w_star[0] * W[0]^-1)^(-lambda_w^-1) + xi_w * (W[-1] * W[0]^-1)^(-lambda_w^-1) * (pi[0]^-1 * pi[-1]^gamma_w)^(-lambda_w^-1)\n    -Phi - Y_s[0] + epsilon_a[0] * L[0]^(1 - alpha) * (K[-1] * z[0])^alpha\n    -Phi - Y_f[0] * P_j_f[0]^(-lambda_p^-1 * (1 + lambda_p)) + epsilon_a[0] * L_f[0]^(1 - alpha) * (K_f[-1] * z_f[0])^alpha\n    std_eta_b * eta_b[x] - log(epsilon_b[0]) + rho_b * log(epsilon_b[-1])\n    -std_eta_L * eta_L[x] - log(epsilon_L[0]) + rho_L * log(epsilon_L[-1])\n    std_eta_I * eta_I[x] - log(epsilon_I[0]) + rho_I * log(epsilon_I[-1])\n    std_eta_w * eta_w[x] - f_1[0] + f_2[0]\n    std_eta_a * eta_a[x] - log(epsilon_a[0]) + rho_a * log(epsilon_a[-1])\n    std_eta_p * eta_p[x] - g_1[0] + g_2[0] * (1 + lambda_p)\n    std_eta_G * eta_G[x] - log(epsilon_G[0]) + rho_G * log(epsilon_G[-1])\n    -f_1[0] + beta * xi_w * f_1[1] * (w_star[0]^-1 * w_star[1])^(lambda_w^-1) * (pi[1]^-1 * pi[0]^gamma_w)^(-lambda_w^-1) + epsilon_b[0] * w_star[0] * L[0] * (1 + lambda_w)^-1 * (C[0] - h * C[-1])^(-sigma_c) * (w_star[0] * W[0]^-1)^(-lambda_w^-1 * (1 + lambda_w))\n    -f_2[0] + beta * xi_w * f_2[1] * (w_star[0]^-1 * w_star[1])^(lambda_w^-1 * (1 + lambda_w) * (1 + sigma_l)) * (pi[1]^-1 * pi[0]^gamma_w)^(-lambda_w^-1 * (1 + lambda_w) * (1 + sigma_l)) + omega * epsilon_b[0] * epsilon_L[0] * (L[0] * (w_star[0] * W[0]^-1)^(-lambda_w^-1 * (1 + lambda_w)))^(1 + sigma_l)\n    -g_1[0] + beta * xi_p * pi_star[0] * g_1[1] * pi_star[1]^-1 * (pi[1]^-1 * pi[0]^gamma_p)^(-lambda_p^-1) + epsilon_b[0] * pi_star[0] * Y[0] * (C[0] - h * C[-1])^(-sigma_c)\n    -g_2[0] + beta * xi_p * g_2[1] * (pi[1]^-1 * pi[0]^gamma_p)^(-lambda_p^-1 * (1 + lambda_p)) + epsilon_b[0] * mc[0] * Y[0] * (C[0] - h * C[-1])^(-sigma_c)\n    -nu_w[0] + (1 - xi_w) * (w_star[0] * W[0]^-1)^(-lambda_w^-1 * (1 + lambda_w)) + xi_w * nu_w[-1] * (W[-1] * pi[0]^-1 * W[0]^-1 * pi[-1]^gamma_w)^(-lambda_w^-1 * (1 + lambda_w))\n    -nu_p[0] + (1 - xi_p) * pi_star[0]^(-lambda_p^-1 * (1 + lambda_p)) + xi_p * nu_p[-1] * (pi[0]^-1 * pi[-1]^gamma_p)^(-lambda_p^-1 * (1 + lambda_p))\n    -K[0] + K[-1] * (1 - tau) + I[0] * (1 - 0.5 * varphi * (-1 + I[-1]^-1 * epsilon_I[0] * I[0])^2)\n    -K_f[0] + K_f[-1] * (1 - tau) + I_f[0] * (1 - 0.5 * varphi * (-1 + I_f[-1]^-1 * epsilon_I[0] * I_f[0])^2)\n    U[0] - beta * U[1] - epsilon_b[0] * ((1 - sigma_c)^-1 * (C[0] - h * C[-1])^(1 - sigma_c) - omega * epsilon_L[0] * (1 + sigma_l)^-1 * L_s[0]^(1 + sigma_l))\n    U_f[0] - beta * U_f[1] - epsilon_b[0] * ((1 - sigma_c)^-1 * (C_f[0] - h * C_f[-1])^(1 - sigma_c) - omega * epsilon_L[0] * (1 + sigma_l)^-1 * L_s_f[0]^(1 + sigma_l))\n    -epsilon_b[0] * (C[0] - h * C[-1])^(-sigma_c) + q[0] * (1 - 0.5 * varphi * (-1 + I[-1]^-1 * epsilon_I[0] * I[0])^2 - varphi * I[-1]^-1 * epsilon_I[0] * I[0] * (-1 + I[-1]^-1 * epsilon_I[0] * I[0])) + beta * varphi * I[0]^-2 * epsilon_I[1] * q[1] * I[1]^2 * (-1 + I[0]^-1 * epsilon_I[1] * I[1])\n    -epsilon_b[0] * (C_f[0] - h * C_f[-1])^(-sigma_c) + q_f[0] * (1 - 0.5 * varphi * (-1 + I_f[-1]^-1 * epsilon_I[0] * I_f[0])^2 - varphi * I_f[-1]^-1 * epsilon_I[0] * I_f[0] * (-1 + I_f[-1]^-1 * epsilon_I[0] * I_f[0])) + beta * varphi * I_f[0]^-2 * epsilon_I[1] * q_f[1] * I_f[1]^2 * (-1 + I_f[0]^-1 * epsilon_I[1] * I_f[1])\n    std_eta_pi * eta_pi[x] - log(pi_obj[0]) + rho_pi_bar * log(pi_obj[-1]) + log(calibr_pi_obj) * (1 - rho_pi_bar)\n    -C[0] - I[0] - T[0] + Y[0] - psi^-1 * r_k[ss] * K[-1] * (-1 + exp(psi * (-1 + z[0])))\n    -calibr_pi + std_eta_R * eta_R[x] - log(R[ss]^-1 * R[0]) + r_Delta_pi * (-log(pi[ss]^-1 * pi[-1]) + log(pi[ss]^-1 * pi[0])) + r_Delta_y * (-log(Y[ss]^-1 * Y[-1]) + log(Y[ss]^-1 * Y[0]) + log(Y_f[ss]^-1 * Y_f[-1]) - log(Y_f[ss]^-1 * Y_f[0])) + rho * log(R[ss]^-1 * R[-1]) + (1 - rho) * (log(pi_obj[0]) + r_pi * (-log(pi_obj[0]) + log(pi[ss]^-1 * pi[-1])) + r_Y * (log(Y[ss]^-1 * Y[0]) - log(Y_f[ss]^-1 * Y_f[0])))\n    -C_f[0] - I_f[0] + Pi_ws_f[0] - T_f[0] + Y_f[0] + L_s_f[0] * W_disutil_f[0] - L_f[0] * W_f[0] - psi^-1 * r_k_f[ss] * K_f[-1] * (-1 + exp(psi * (-1 + z_f[0])))\n    epsilon_b[0] * (K[-1] * r_k[0] - r_k[ss] * K[-1] * exp(psi * (-1 + z[0]))) * (C[0] - h * C[-1])^(-sigma_c)\n    epsilon_b[0] * (K_f[-1] * r_k_f[0] - r_k_f[ss] * K_f[-1] * exp(psi * (-1 + z_f[0]))) * (C_f[0] - h * C_f[-1])^(-sigma_c)\nend","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"First, we load the package and then use the @model macro to define our model. The first argument after @model is the model name and will be the name of the object in the global environment containing all information regarding the model. The second argument to the macro are the equations, which we write down between begin and end. Equations can contain an equality sign or the expression is assumed to equal 0. Equations cannot span multiple lines and the timing of endogenous variables are expressed in the squared brackets following the variable name (e.g. [-1] for the past period). Exogenous variables (shocks) are followed by a keyword in squared brackets indicating them being exogenous (in this case [x]). In this example there are also variables in the non stochastic steady state denoted by [ss]. Note that names can leverage julia's unicode capabilities (alpha can be written as Œ±).","category":"page"},{"location":"tutorials/sw03/#Define-the-parameters","page":"Smets and Wouters (2003)","title":"Define the parameters","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Next we need to add the parameters of the model. The macro @parameters takes care of this:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"@parameters SW03 begin  \n    lambda_p = .368\n    G_bar = .362\n    lambda_w = 0.5\n    Phi = .819\n\n    alpha = 0.3\n    beta = 0.99\n    gamma_w = 0.763\n    gamma_p = 0.469\n    h = 0.573\n    omega = 1\n    psi = 0.169\n\n    r_pi = 1.684\n    r_Y = 0.099\n    r_Delta_pi = 0.14\n    r_Delta_y = 0.159\n\n    sigma_c = 1.353\n    sigma_l = 2.4\n    tau = 0.025\n    varphi = 6.771\n    xi_w = 0.737\n    xi_p = 0.908\n\n    rho = 0.961\n    rho_b = 0.855\n    rho_L = 0.889\n    rho_I = 0.927\n    rho_a = 0.823\n    rho_G = 0.949\n    rho_pi_bar = 0.924\n\n    std_eta_b = 0.336\n    std_eta_L = 3.52\n    std_eta_I = 0.085\n    std_eta_a = 0.598\n    std_eta_w = 0.6853261\n    std_eta_p = 0.7896512\n    std_eta_G = 0.325\n    std_eta_R = 0.081\n    std_eta_pi = 0.017\n\n    calibr_pi_obj | 1 = pi_obj[ss]\n    calibr_pi | pi[ss] = pi_obj[ss]\nend","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The block defining the parameters above has three different inputs.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"First, there are simple parameter definition the same way you assign values (e.g. Phi = .819).","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Second, there are calibration equations where we treat the value of a parameter as unknown (e.g. calibr_pi_obj) and want an additional equation to hold (e.g. 1 = pi_obj[ss]). The additional equation can contain variables in SS or parameters. Putting it together a calibration equation is defined by the unknown parameter, and the calibration equation, separated by | (e.g. calibr_pi_obj | 1 = pi_obj[ss] and also 1 = pi_obj[ss] | calibr_pi_obj).","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"<!‚Äì Third, information about the domain of variables and parameters are passed on (e.g. 0 < C). This is useful information for the symbolic and numerical solvers of the SS. ‚Äì>","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Note that we have to write one parameter definition per line.","category":"page"},{"location":"tutorials/sw03/#Plot-impulse-response-functions-(IRFs)","page":"Smets and Wouters (2003)","title":"Plot impulse response functions (IRFs)","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Given the equations and parameters, we have everything to solve the model and do some analysis. A common output are IRFs for the exogenous shocks. Calling plot_irf (different names for the same function are also supported: plot_irfs, or plot_IRF) will take care of this. In the background the package solves (numerically in this complex case) for the non stochastic steady state (SS) and calculates the first order perturbation solution.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"plot_irf(SW03)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"(Image: RBC IRF)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"When the model is solved the first time (in this case by calling plot_irf), the package breaks down the steady state problem into independent blocks and first attempts to solve them symbolically and if that fails numerically.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The plots show the responses of the endogenous variables to a one standard deviation positive (indicated by Shock‚Å∫ in chart title) unanticipated shock. Therefore there are as many subplots as there are combinations of shocks and endogenous variables (which are impacted by the shock). Plots are composed of up to 9 subplots and the plot title shows the model name followed by the name of the shock and which plot we are seeing out of the plots for this shock (e.g. (1/3) means we see the first out of three plots for this shock). Subplots show the sorted endogenous variables with the left y-axis showing the level of the respective variable and the right y-axis showing the percent deviation from the SS (if variable is strictly positive). The horizontal black line marks the SS.","category":"page"},{"location":"tutorials/sw03/#Explore-other-parameter-values","page":"Smets and Wouters (2003)","title":"Explore other parameter values","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Playing around with the model can be especially insightful in the early phase of model development. The package tries to facilitate this process to the extent possible. Typically one wants to try different parameter values and see how the IRFs change. This can be done by using the parameters argument of the plot_irf function. We pass a Pair with the Symbol of the parameter (: in front of the parameter name) we want to change and its new value to the parameter argument (e.g. :alpha => 0.305). Furthermore, we want to focus on certain shocks and variables. We select for the example the eta_R shock by passing it as a Symbol to the shocks argument of the plot_irf function. For the variables we choose to plot: U, Y, I, R, and C and achieve that by passing the Vector of Symbols to the variables argument of the plot_irf function:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"plot_irf(SW03, \n         parameters = :alpha => 0.305, \n         variables = [:U,:Y,:I,:R,:C], \n         shocks = :eta_R)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"(Image: IRF plot)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"First, the package finds the new steady state, solves the model dynamics around it and saves the new parameters and solution in the model object. Second, note that with the parameters the IRFs changed (e.g. compare the y-axis values for U). Updating the plot for new parameters is significantly faster than calling it the first time. This is because the first call triggers compilations of the model functions, and once compiled the user benefits from the performance of the specialised compiled code. Furthermore, finding the SS from a valid SS as a starting point is faster.","category":"page"},{"location":"tutorials/sw03/#Plot-model-simulation","page":"Smets and Wouters (2003)","title":"Plot model simulation","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Another insightful output is simulations of the model. Here we can use the plot_simulations function. Again we want to only look at a subset of the variables and specify it in the variables argument. To the same effect we can use the plot_irf function and specify in the shocks argument that we want to :simulate the model and set the periods argument to 100.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"plot_simulations(SW03, variables = [:U,:Y,:I,:R,:C])","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"(Image: Simulate SW03)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The plots show the models endogenous variables in response to random draws for all exogenous shocks over 100 periods.","category":"page"},{"location":"tutorials/sw03/#Plot-specific-series-of-shocks","page":"Smets and Wouters (2003)","title":"Plot specific series of shocks","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Sometimes one has a specific series of shocks in mind and wants to see the corresponding model response of endogenous variables. This can be achieved by passing a Matrix or KeyedArray of the series of shocks to the shocks argument of the plot_irf function. Let's assume there is a positive 1 standard deviation shock to eta_b in period 2 and a negative 1 standard deviation shock to eta_w in period 12. This can be implemented as follows:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"using AxisKeys\nshock_series = KeyedArray(zeros(2,12), Shocks = [:eta_b, :eta_w], Periods = 1:12)\nshock_series[1,2] = 1\nshock_series[2,12] = -1\nplot_irf(SW03, shocks = shock_series, variables = [:W,:r_k,:w_star,:R])","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"(Image: Series of shocks RBC)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"First, we construct the KeyedArray containing the series of shocks and pass it to the shocks argument. The plot shows the paths of the selected variables for the two shocks hitting the economy in periods 2 and 12 and 40 quarters thereafter.","category":"page"},{"location":"tutorials/sw03/#Model-statistics","page":"Smets and Wouters (2003)","title":"Model statistics","text":"","category":"section"},{"location":"tutorials/sw03/#Steady-state","page":"Smets and Wouters (2003)","title":"Steady state","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The package solves for the SS automatically and we got an idea of the SS values in the plots. If we want to see the SS values and the derivatives of the SS with respect to the model parameters we can call get_steady_state. The model has 39 parameters and 54 variables. Since we are not interested in all derivatives for all parameters we select a subset. This can be done by passing on a Vector of Symbols of the parameters to the parameter_derivatives argument:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"get_steady_state(SW03, parameter_derivatives = [:alpha,:beta])","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The first column of the returned matrix shows the SS while the second to last columns show the derivatives of the SS values (indicated in the rows) with respect to the parameters (indicated in the columns). For example, the derivative of C with respect to beta is 14.4994. This means that if we increase beta by 1, C would increase by 14.4994 approximately. Let's see how this plays out by changing beta from 0.99 to 0.991 (a change of +0.001):","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"get_steady_state(SW03, \n                 parameter_derivatives = [:alpha,:G_bar], \n                 parameters = :beta => .991)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Note that get_steady_state like all other get functions has the parameters argument. Hence, whatever output we are looking at we can change the parameters of the model.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The new value of beta changed the SS as expected and C increased by 0.01465. The elasticity (0.01465/0.001) comes close to the partial derivative previously calculated. The derivatives help understanding the effect of parameter changes on the steady state and make for easier navigation of the parameter space.","category":"page"},{"location":"tutorials/sw03/#Standard-deviations","page":"Smets and Wouters (2003)","title":"Standard deviations","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Next to the SS we can also show the model implied standard deviations of the model. get_standard_deviation takes care of this. Additionally we will set the parameter values to what they were in the beginning by passing on a Tuple of Pairs containing the Symbols of the parameters to be changed and their new (initial) values (e.g. (:alpha => 0.3, :beta => .99)).","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"get_standard_deviation(SW03, \n                       parameter_derivatives = [:alpha,:beta], \n                       parameters = (:alpha => 0.3, :beta => .99))","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The function returns the model implied standard deviations of the model variables and their derivatives with respect to the model parameters. For example, the derivative of the standard deviation of q with resect to alpha is -19.0184. In other words, the standard deviation of q decreases with increasing alpha.","category":"page"},{"location":"tutorials/sw03/#Correlations","page":"Smets and Wouters (2003)","title":"Correlations","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Another useful statistic is the model implied correlation of variables. We use get_correlation for this:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"get_correlation(SW03)","category":"page"},{"location":"tutorials/sw03/#Autocorrelations","page":"Smets and Wouters (2003)","title":"Autocorrelations","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Next, we have a look at the model implied aautocorrelations of model variables using the get_autocorrelation function:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"get_autocorrelation(SW03)","category":"page"},{"location":"tutorials/sw03/#Variance-decomposition","page":"Smets and Wouters (2003)","title":"Variance decomposition","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The model implied contribution of each shock to the variance of the model variables can be calculate by using the  get_variance_decomposition function:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"get_variance_decomposition(SW03)","category":"page"},{"location":"tutorials/sw03/#Conditional-variance-decomposition","page":"Smets and Wouters (2003)","title":"Conditional variance decomposition","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Last but not least, we have look at the model implied contribution of each shock per period to the variance of the model variables (also called forecast error variance decomposition) by using the  get_conditional_variance_decomposition function:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"get_conditional_variance_decomposition(SW03)","category":"page"},{"location":"tutorials/sw03/#Plot-conditional-variance-decomposition","page":"Smets and Wouters (2003)","title":"Plot conditional variance decomposition","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Especially for the conditional variance decomposition it is convenient to look at a plot instead of the raw numbers. This can be done using the plot_conditional_variance_decomposition function:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"plot_conditional_variance_decomposition(SW03, variables = [:U,:Y,:I,:R,:C])","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"(Image: FEVD SW03)","category":"page"},{"location":"tutorials/sw03/#Model-solution","page":"Smets and Wouters (2003)","title":"Model solution","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"A further insightful output are the policy and transition functions of the the first order perturbation solution. To retrieve the solution we call the function get_solution:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"get_solution(SW03)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The solution provides information about how past states and present shocks impact present variables. The first row contains the SS for the variables denoted in the columns. The second to last rows contain the past states, with the time index ‚Çç‚Çã‚ÇÅ‚Çé, and present shocks, with exogenous variables denoted by ‚Çç‚Çì‚Çé. For example, the immediate impact of a shock to eta_w on z is 0.00222469.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"There is also the possibility to visually inspect the solution using the plot_solution function:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"plot_solution(SW03, :pi, variables = [:C, :I,:K,:L])","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"(Image: SW03 solution)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The chart shows the first order perturbation solution mapping from the past state pi to the present variables C, I, K, and L. The state variable covers a range of two standard deviations around the non stochastic steady state and all other states remain in the non stochastic steady state.","category":"page"},{"location":"tutorials/sw03/#Obtain-array-of-IRFs-or-model-simulations","page":"Smets and Wouters (2003)","title":"Obtain array of IRFs or model simulations","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Last but not least the user might want to obtain simulated time series of the model or IRFs without plotting them. For IRFs this is possible by calling get_irf:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"get_irf(SW03)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"which returns a 3-dimensional KeyedArray with variables in rows, the period in columns, and the shocks as the third dimension.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"For simulations this is possible by calling simulate:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"simulate(SW03)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"which returns the simulated data in a 3-dimensional KeyedArray of the same structure as for the IRFs.","category":"page"},{"location":"tutorials/sw03/#Conditional-forecasts","page":"Smets and Wouters (2003)","title":"Conditional forecasts","text":"","category":"section"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Conditional forecasting is a useful tool to incorporate for example forecasts into a model and then add shocks on top.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"For example we might be interested in the model dynamics given a path for Y and pi for the first 4 quarters and the next quarter a negative shock to eta_w arrives. Furthermore, we want that the first two periods only a subset of shocks is used to match the conditions on the endogenous variables. This can be implemented using the get_conditional_forecast function and visualised with the plot_conditional_forecast function.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"First, we define the conditions on the endogenous variables as deviations from the non stochastic steady state (Y and pi in this case) using a KeyedArray from the AxisKeys package (check get_conditional_forecast for other ways to define the conditions):","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"using AxisKeys\nconditions = KeyedArray(Matrix{Union{Nothing,Float64}}(undef,2,4),Variables = [:Y, :pi], Periods = 1:4)\nconditions[1,1:4] .= [-.01,0,.01,.02];\nconditions[2,1:4] .= [.01,0,-.01,-.02];","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Note that all other endogenous variables not part of the KeyedArray are also not conditioned on.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Next, we define the conditions on the shocks using a Matrix (check get_conditional_forecast for other ways to define the conditions on the shocks):","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"shocks = Matrix{Union{Nothing,Float64}}(undef,9,5)\nshocks[[1:3...,5,9],1:2] .= 0;\nshocks[9,5] = -1;","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The above shock Matrix means that for the first two periods shocks 1, 2, 3, 5, and 9 are fixed at zero and in the fifth period there is a negative shock of eta_w (the 9th shock).","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Finally we can get the conditional forecast:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"get_conditional_forecast(SW03, conditions, shocks = shocks, variables = [:Y,:pi,:W])","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"The function returns a KeyedArray with the values of the endogenous variables and shocks matching the conditions exactly.","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"We can also plot the conditional forecast using:","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"plot_conditional_forecast(SW03,conditions, shocks = shocks, plots_per_page = 6,variables = [:Y,:pi,:W])","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"(Image: SW03 conditional forecast 1)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"(Image: SW03 conditional forecast 2)","category":"page"},{"location":"tutorials/sw03/","page":"Smets and Wouters (2003)","title":"Smets and Wouters (2003)","text":"Note that the stars indicate the values the model is conditioned on.","category":"page"},{"location":"unfinished_docs/dsl/#DSL","page":"-","title":"DSL","text":"","category":"section"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"MacroModelling parses models written using a user-friendly syntax:","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"@model RBC begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * eps_z[x]\nend","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"The most important rule is that variables are followed by the timing in squared brackets for endogenous variables, e.g. Y[0], exogenous variables are marked by certain keywords (see below), e.g. œµ[x], and parameters need no further syntax, e.g. Œ±.","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"A model written with this syntax allows the parser to identify, endogenous and exogenous variables and their timing as well as parameters.","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"Note that variables in the present (period t or 0) have to be denoted as such: [0]. The parser also takes care of creating auxilliary variables in case the model contains leads or lags of the variables larger than 1:","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"@model RBC_lead_lag begin\n    1  /  c[0] = (Œ≤  /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))\n    c[0] + k[0] = (1 - Œ¥) * k[-1] + q[0]\n    q[0] = exp(z[0]) * k[-1]^Œ±\n    z[0] = œÅ * z[-1] + std_z * (eps_z[x-8] + eps_z[x-4] + eps_z[x+4] + eps_z_s[x])\n    cÃÑ‚Åª[0] = (c[0] + c[-1] + c[-2] + c[-3]) / 4\n    cÃÑ‚Å∫[0] = (c[0] + c[1] + c[2] + c[3]) / 4\nend","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"The parser recognises a variable as exogenous if the timing bracket contains one of the keyword/letters (case insensitive): x, ex, exo, exogenous. ","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"Valid declarations of exogenous variables: œµ[x], œµ[Exo], œµ[exOgenous]. ","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"Invalid declarations: œµ[xo], œµ[exogenously], œµ[main shock x]","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"Endogenous and exogenous variables can be in lead or lag, e.g.:  the following describe a lead of 1 period: Y[1], Y[+1], Y[+ 1], eps[x+1], eps[Exo + 1] and the same goes for lags and periods > 1: `k[-2], c[+12], eps[x-4]","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"Invalid declarations: Y[t-1], Y[t], Y[whatever], eps[x+t+1]","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"Equations must be within one line and the = sign is optional.","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"The parser recognises all functions in julia including those from StatsFuns.jl. Note that the syntax for distributions is the same as in MATLAB, e.g. normcdf. For those familiar with R the following also work: pnorm, dnorm, qnorm, and it also recognises: norminvcdf and norminv.","category":"page"},{"location":"unfinished_docs/dsl/","page":"-","title":"-","text":"Given these rules it is straightforward to write down a model. Once declared using the @model <name of the model> macro, the package creates an object containing all necessary information regarding the equations of the model.","category":"page"},{"location":"unfinished_docs/dsl/#Lead-/-lags-and-auxilliary-variables","page":"-","title":"Lead / lags and auxilliary variables","text":"","category":"section"}]
}
